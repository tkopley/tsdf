;    Time-Series Data Format (TSDF) Syntax Specification
;    ---------------------------------------------------
;      Tom Kopley
;      Palo Alto, CA  
;      tkopley@yahoo.com
;
; $Id$
; Preliminary Release, version 0.7 March 1, 2020
;
; This is the syntax specification for Time-Series Data Format (TSDF)
; in Backus-Naur Form.  Each section corresponds to one of the files in
; the format.  After the BNF rule definition, there is a section
; of comments that help translate the BNF into plain English.
;
; --------
; CONTENTS
; --------
;   1. Introduction
;   2. Limitations
;   3. Practical Issues
;   4. Notes on Analysis Program Compliance
;   5. Common rules for all TSDF files
;   6. Rules and comments for sessioninfo file
;   7. Rules and comments for devinfo file
;   8. Rules and comments for stressinfo file
;   9. Rules and comments for splitinfo file
;  10. Rules and comments for waferinfo file
;  10. Rules and comments for miscinfo file
;  11. Rules and comments for mdef file
;  12. Rules and comments for mtimes file
;  13. Rules and comments for stimes file
;  14. Rules and comments for mdat file
;  15. Rules and comments for sdat file
;  16. Rules and comments for ivdat file
;  17. Rules and comments for predef file
;  18. Rules and comments for predat file
;  19. Rules and comments for postdef file
;  20. Rules and comments for postdat file
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ****************
; * Introduction *
; ****************
;
; TSDF is a file format for reliability degradation data, specifically 
; degradation data from semiconductor devices.  It aims to take potentially
; large amounts of reliability data and put it into a small number of files
; that are human readable.  TSDF does this by separating metadata from raw
; data.  Metadata are things like stress and test conditions, tester
; information, timestamps, split information, and other information.
; With this separation, it is easy for a user to view or search through a
; set of TSDF files to get the information needed to put the data in
; context (process, lots, wafers, components, tester, test type, etc.).
;
; Of course, human readability is really only for the information
; (metadata) files.  The data files can be too dense with numbers to be
; of any use to view with a text editor.  It is expected some type of
; data analysis program will be used to graphically illustrate the
; data.  We hope such a standard will inspire someone to write a
; data analysis program that can also become an industry standard.
;
; It should be obvious by now that TSDF uses the English language
; for metadata, as English is the lingua franca of the world's science
; and engineering community.  There are a few comment lines allowing
; free-form text, and for users within a company located in a country
; with a native language other than English, these comments may of course
; be in the native language.  For exchange of data among entities with
; different native languages, English is the recommended language for these
; comments.
;
; To understand TSDF's organization, it helps to understand how semiconductor
; reliability data is typically taken and organized for analysis, and how this
; activity fits within a larger reliability lab operational model.  Typical 
; reliability data is taken on one or more Devices Under Test (DUTs), with 
; multiple devices stressed in parallel at accelerated temperature and bias, 
; taken off stress, and degradation monitored by serially measuring appropriate
; parameters for each device. This cycle of stress/measure is repeated, usually
; logarithmically, that is, a fixed number of stress/measure cycles per decade
; of time.  The DUTs may be packaged devices placed in a test fixture, or 
; wafer-level components connected to the stress tester with probes.  At the
; package-level, stress tests usually last days to months.  At the wafer-level,
; a single touchdown of probes can be performed with a long-term stress
; (typically hours to weeks), or alternately, many touchdowns on different
; sites within the wafer may be performed, with each stress lasting for a short
; time (seconds to minutes).
;
; The data collected for each of these types of test scenarios forms a dataset
; that we call a "stress session."  In fact, in this specification, "dataset"
; and "stress session" are interchangable names for the same thing. TSDF archives
; the datasets into a self-contained set of files that can be put into a database
; or exchanged between engineers, researchers, and even different semiconductor
; companies.
;
; Multiple stress sessions may be performed, each at say a different 
; temperature or stress bias, then analyzed together in a "analysis session"
; with the data fit to a particular reliability model.
;
; The infrastructure needed to generate datasets varies acress labs and
; entities, so any of that ancillary information is not specified in TSDF. For
; example, a lab may have a database of test programs used for various stress
; tests and would like to have a reference from the TSDF dataset to the test program
; database.  Obviously, TSDF cannot anticipate every test program database schema
; or naming convention, so doesn't even try!  The same is true for other
; infrastructure information such as a job tracking system or accounting system.
; TSDF does allow references to such infrastructure information via the miscinfo
; file, which contains miscellaneous (field,value) pairs.  These miscellaneous
; fields are put in a separate file so as not to clutter the sessioninfo file 
; with fields that might not even be filled. If stuffing a database with a TSDF
; dataset, the miscinfo fields may be ignored or imported if the database contains
; fields for the information.  This allows TSDF to be independent of a lab's
; other database infrastructure while also having some mechanism to capture
; the lab's important infrastructure information.
;
; TSDF consists of the following files:
;   o> sessioninfo -- basic stress session information
;   o> devinfo     -- information on devices under test
;   o> stressinfo  -- stress biases and temperatures
;   o> splitinfo   -- lot experimental split information
;   o> waferinfo   -- wafer information, like notch location and waferscribe:id map
;   o> miscinfo    -- miscellaneous information not defined specifically by TSDF
;   o> mtimes      -- stress times for each device
;   o> stimes      -- measurement times for stress parameters for each device
;   o> mdef        -- monitor parameter definitions
;   o> mdat        -- monitor parameter data
;   o> sdat        -- stress parameter data
;   o> ivdat       -- IV curve data, one file for each device
;   o> predef      -- pre-stress parameter definitions
;   o> predat      -- pre-stress parameter data
;   o> postdef     -- post-stress parameter definitions
;   o> postdef     -- post-stress parameter data
;
; The files are logically grouped together by dataset using a "session
; name."  In the simplest form of a database, the datasets would be
; grouped under file system directories named by their respective
; session names. 
;
; The minimum set of files for a stress session to be considered a valid
; TSDF dataset are: sessioninfo, mtimes, and mdat for degradation data and
; sessioninfo, mtimes, and ivdat for IV data.  Furthermore, sessioninfo
; could contain all blank entries except number of devices, and any
; TSDF-compliant analysis program could still produce monitor parameter vs
; stress time curves.  See the section below on the requirements of an
; analysis program to be TSDF-compliant.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ***************
; * Limitations *
; ***************
;
; TSDF has known limitations for dealing with reliability datasets, mostly
; metadata.  Here is a list of know limitations, and TSDF extensions
; needed to address them.  It is expected that extensions to TSDF will
; be developed by the reliability community as the need arises.
;
; 1. Lack of detailed device information in devinfo file
;
;   This is the most obvious limitation to TSDF, and it stems from a
;   design decision made early on that the devinfo file will be simple
;   and have a fixed number of columns.  There are so many possible 
;   types of devices to do reliability testing on, with each type having
;   a unique set of parameters needed to describe it.  As such, it
;   was deemed unrealistic to be able to anticipate every type of device
;   that would be incorporated in a reliability test, so no attempt was
;   made to define devinfo columns based on device type.  The workaround
;   we implemented was to put the detailed device data in a separate file
;   that was then read in by the analysis program.  Anticipating this
;   workaround might not be suitable to all users, we added a "misc_info"
;   column to the devinfo in which detailed device information could be
;   stored.  In either case, the detailed device information is not a
;   standard, and thus not very useful for data exchange.
;
;   Clearly, a useful extension to TSDF to would be a standardized way to
;   capture device details.
;
;
; 2. Lack of detailed waveform information for AC stress in stressinfo file
;  
;   This limitation is similar to the device detail limitation: there
;   are so many possible AC stress waveforms, that it is not possible to 
;   anticipate them all, and thus not possible to define a standard.
;   An extension of TSDF to capture AC stress waveforms would be based on
;   other existing formats, if any exist, or defining a new format based
;   on input from the reliability and test community.
;
;
; 3. Lack of a single file to simplify data exchange
;
;   While TSDF is only a small number of files (there could be a large
;   number of ivdat files, these are put under a separate directory for
;   this reason), it still impells users to tar or zip the files
;   together for data exchange.  A single file to exchange would be more
;   convenient.  For this reason, we anticipate the definition of an
;   XML file to hold all data, as an extension of TSDF.
;
; 4. TSDF is not a true database
;
;   All of TSDF files except ivdat are formated as (row,column) data,
;   so could be fairly easily stuffed into a relational database, but
;   there would be some overhead. In several files, there is implicit
;   indexing, as in mdat and sdat files, where row ordering follows
;   time ordering as defined in the mtimes file.  This could easily
;   be put in a standalone database, but putting into a larger database
;   containing many stress sessions would require a fair amount of work.
;   This may be tackled in the future, but for now TSDF is file-based.
;   The implications are that any lab using TSDF to build a library
;   of reliability datasets will need to use other tools to index
;   and allow search of datasets.  Any lab or organization using TSDF
;   may design their own database to put TSDF data into, but exchange
;   of TSDF datasets with other entities would be more difficult.  
;   Utilities to convert from a database to TSDF files and back would
;   be the best workaround in this situation.
;
; 5. Limitations in dealing with reliability data from product and
;    package qualifications
;
;   While all reliability testing essentially follows the stress/measure
;   cycle which TSDF captures very well, the test setup and procedure
;   followed by product reliability testing requires much more DUT and
;   test information to be captured than process and device level 
;   reliability tests (details of which are captured in the lot name or in
;   the optional splitinfo file).  
;
;   First, products are stressed in ovens, but typically taken out of the
;   ovens and tested on functional testers at specific time points.  This
;   is different from process/device reliability testing where the oven
;   and tester are usually hardwired together.  Second, products may be
;   qualified with
;   different combinations of ICs and packages, or use chip-scale packaging.
;   For process/device reliability testing, parts are IC test structures
;   only, although they may be put in packages.  Product packages are
;   described by their bill of materials (BOM), which is essential
;   information that needs to be captured (the BOM includes mold compound,
;   lead frame, bond wire, etc).
;   Third, while on stress, DUTs may be subject to various biasing, from
;   the simple (storage test with no electrical bias or op life testing
;   with DC power up only) to the more complex (dynamic op life with
;   part being exercised with specific test vectors or input waveforms).
;   Fourth, DUTs are placed on PC boards of varying complexity, but which
;   can have large influence on the test results.  Fifth, most monitor
;   testing is pass/fail; degradation testing and/or test-to-fail is rare.
;
;   For these reasons, more metadata is needed to characterize a product
;   reliability test, while less read points (eg. 96 hr, 168 hr, 500 hr,
;   1000 hr) are taken, but the monitor parameters could be many more,
;   for example, all parameters on a product's data sheet.  The TSDF files
;   that would need to be modified to capture product reliability test
;   data include all the metadata files: sessioninfo, devinfo, stressinfo,
;   splitinfo, and mdef.
;
;   TSDF is not set up to handle all the possible variations of product
;   testing at this point, and it may never be.  An extensions to add a
;   buildinfo file to capture BOM information and assembly site is one
;   possibility.  The ramifications of extending TSDF to handle product
;   qualification data has not been fully thought out at this point.
;
;   All that said, it is in the interest of TSDF to support other read
;   point testing as is done for say, wafer level stress migration.
;   This is the most likely scenario that TSDF will support.  While I
;   have not thought out all the details, I could imagine storing
;   all read point data in TSDF stress sessions and having a parent TSDF
;   dataset store those stress session names in a yet to be defined file.
;   Then drift/degradation analysis could be done and the results stored
;   in the analysis session (see the next section right below on new 
;   thoughts on supporting analysis).
;
; 6. TSDF is not designed to hold information on analysis
;  
;   At this point in time, TSDF does not support data or information added
;   after the dataset is complete, as would be the case for analyses
;   that manipulate the data and extract useful information or other
;   data.  For example, one might define a new monitor parameter
;   and extract it from existing monitor IV curves.  It would be natural
;   to add that parameter to the mdat file, but that is not supported.
;   The user could "hack" TSDF to add such data, but there is no
;   mechanism to timestamp the analysis or create a paper trail of what
;   data manipulations occurred.  In another example, if one created a
;   report or series of reports from a given dataset, it would be 
;   convenient to back annotate the TSDF files with entries for references
;   to these reports. That could be done in the miscinfo file for example,
;   but would be purely a user input.  
;
;   Support for tracking data analysis is planned for the future and ideas
;   are being formulated. Most likely, TSDF will define "analysis session"
;   data files analogous to "stress session" data files.  Analysis details
;   (and timestamps) would be saved in the analysis sesssion's files
;   and then analysis programs integrated with TSDF could concatenate
;   the original data with extracted data from an analysis session.  To
;   that end, v0.8 of TSDF will add lifedat and lifedef files in 
;   anticipation of supporting analysis.  These files are technically not
;   needed in TSDF at present because stresses that yield test-to-fail
;   data can simply use the cumulative stress times in the mtimes file
;   to store lifetime data. But they could exist in analysis session
;   files if an analysis performed an alternate lifetime extraction of
;   existing data. A stress session and any number of associated analysis
;   sessions could be concatenated together to give a complete history of
;   the dataset from original data to extracted data.  Of course, the
;   trade-off will be having to deal with multiple TSDF sessions, at 
;   least doubling the number of files (unless the original dataset had
;   a lot of ivdat files) and making the issue discussed in #3 above
;   even more of an issue.
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ********************
; * Practical Issues *
; ********************
;
; One common issue with using TSDF is that data files from commericial
; or home-built test systems rarely contain all the information TSDF
; is expecting. One workaround is to create a separate "extras" file 
; that contains the missing but useful information.  Any conversion program 
; that one writes can then look for the existance of this extras file.
;
; The nature of TSDF lends itself to a limited number of ways to organize
; extras data into a file.  The data itself will be coming off the
; tester and saved in the data files.  This leaves only metadata files
; (*info and *def files) that might need augmentation from the user.
; Of theses metadata files, most are "all or nothing" kinds of things.
; In other words, if stress condition information is available, it
; can go right into the stressinfo file from the test system data files.
; Likewise for parameter definitions, it's either all or nothing, and if
; it is "all," then one would write the mdef file directly.  Only
; the sessioninfo file, devinfo, and miscinfo files contain fields that
; lend themselves to patching in metadata as needed.  Given these TSDF
; driven constraints, the author has had success creating a 
; tsdf_extras.txt file with the format shown below. Metadata is 
; grouped by TSDF file using XML-like tags for the filename:
;
; For fields within sessioninfo:
;  <sessioninfo>
;    <key>=<value>
;  </sessioninfo>
; where <key> is any field found in session info (comment, probecard,
; operator, etc) and <value> is a valid TSDF value for that field.
;
; For fields within miscinfo:
;  <miscinfo>
;    <key>=<value>
;  </miscinfo>
; where <key> is any field the user wants to save as miscellaneous info
; and <value> is the value for that field.
;
; For device information, it is most likely "all or nothing" for 
; certain information that should map to individual columns within 
; devinfo. So a reasonable format would be:
;   <devinfo>
;      <column_name1> <column_name2> ... <column_nameN>
;      <dev1_data1>    <dev1_data2>    ... <dev1_dataN>
;      <dev2_data1>    <dev2_data2>    ... <dev2_dataN>
;           .               .                   .
;           .               .                   .
;           .               .                   .
;      <devM_data1>    <devM_data2>    ... <devM_dataN>
;   </devinfo>
; where each column is for missing device info for that column only
; and all devices must be included in the column (and of course be in
; a specified row order so it can be merged into other existing
; device info unambiguously.
;
; For other files, just load the entire file contents:
;   <filename>
;     <filecontents>
;   </filename>
; where <filename> and </filename> contain the TSDF filename, mdef,
; stressinfo, etc., and <filecontents> is the metadata for the file
; in whatever format you'd like (but the easiest is to just put it
; in TSDF format and read it in directly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ****************************************
; * Notes on Analysis Program Compliance *
; ****************************************
;
; There are only a few requirements for an analysis program to be considered 
; TSDF-compliant:
;   1. It will have to be able to deal with the minimum set of files
;       that can be in a dataset.  These would be sessioninfo, mtimes,
;       and mdat files OR the sessioninfo, mtimes, and ivdat files.
;       With these files, a program will know the number of
;       devices in the dataset, and basic parameter vs stress time plots
;       or IV curves can be generated.  In fact, the sessioninfo file could
;       contain all blank entries except number of devices and figure out 
;       the rest.
;   2. It has to be able to read all the files, including variations in
;       formats.
; The actual plots can be whatever the user finds useful.  Same for 
; extrapolations (or interpolations) of degradation data to a user-defined
; fail value.  Fail value examples are 10% change in Idsat for hot-carrier
; injection, or 20% increase in metal line resistance for electromigration.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ****************
; * Common Rules *
; ****************
;
; common Backus-Naur Form rules for TSDF file syntax
;
; !syntax("abnf")

<letter> ::= 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|

<digit> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'

<alphanumeric> ::= <letter> | <digit> | "_"

<pos_number> ::=  <digit>+ ["." <digit>+] [("E"|"e") (["+"]|"-") <digit>+]
<number> ::= ["-"] <pos_number>
<integer_list> ::= (<digit>+ [":" <digit>+ [":" <digit>+]] <whitespace>)+
<number_list> ::= (<number> [":" <number> ":" <number>] <whitespace>)+

<units_prefix_smaller> ::= "m" | "u" | "n" | "p" | "f" | "a" | "z"
<units_prefix_larger> ::= "k" | "M" | "G" | "T" | "P" | "E" | "Z"
<units_prefix> ::= <units_prefix_smaller> | <units_prefix_larger>
<units> ::= ([<units_prefix>] <letter> | <digit> | '.' | '/' | '^')+

<non_whitespace> ::= <alphanumeric>|'~'|'!'|'@'|'$'|'^'|'&'|'*'|'('|')'|'{'|'}'|'['|']'|'\'|'-'|'+'|'='|':'|';'|'?'|'.'|','|'<'|'>'|'"'|'''|'|'
; This is the full Unicode char set from the W3C XML standard. [] refers to a range,
; not an optional term, so we'll need to make this consisent if we ever use a
; parser generator on this file (and probably convert to Extended BNF).
<unicode> ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

<whitespace> ::= " "+

<text> ::= (<non_whitespace> | <whitespace> | <unicode> )+

<EOL> ::= <newline> | <CRLF>

<padding_data> ::= "44e44"
<bad_data> ::= "21e21"

; These rules define file paths
<unix_path> ::= [<hostname> ":"] <unix_directory_path>
<dos_path> ::= <drive_designation> <dos_directory_path>
<network_path> ::= "\\" <server_name> "\" <dos_directory_path>
  <unix_directory_path> ::= ("/" <directory_name>)+
  <dos_directory_path> ::= ("\" <directory_name>)+
  <drive_designation> ::= <letter> ":"

; This is the set of productions for an equation, from the Dragon Book
; 2nd ed. p. 49, including operator precedence, plus rules for 
; exponentiation (with right associativity) and a few built-in functions
; Note: '@' is the empty set
<expr>  ::= <expr> "+" <term> | <expr> "-" <term> | <term>
<term> ::= <term> "*" <exp> | <term> "/" <exp> | <exp>
<exp> ::= <factor> "^" <exp> | <factor>
<factor> ::= <number> | <function> "(" <expr> ")" | "(" <expr> ")"
<function> = "min" | "max" | "diff" | @

;
; In plain English:
; <alphanumeric> is a single character that can be a letter or a number 0 
;   through 9 or underscore (_).
; <number> is any number with the optional exponent denoted with 'e' or 'E'.
;   Examples: "100" "0.00", "8.54e-12" "5.56E+003".  
;   Note: ".01" is not valid (use "0.01"), but "-0" or "00" are valid!
; <integer_list> uses Matlab's convention for defining a list of 
;   monotonically increasing integers.  The integers can all be listed,
;   or Matlab's shorthand notation can be used, or a mixture of a list of
;   integers and the shorthand notation can be used.  The shorthand notation
;   can be used when there is a constant difference (step) between numbers.
;   The shorthand notation is in the form <start>:<step>:<stop>, with 
;   <step>: optional for <step>=1.
;   For example, to list the integers 1 through 10, the shorthand notation
;   would be 1:10; to list integers 0, 2, 4, 6, and 8, the notation
;   would be 0:2:8.  If there is no common step between integers in the list,
;   all integers are listed.  For example for the list 1 3 7 10, the line
;   would read 1 3 7 10.  An example of a mixture of single integers and
;   shorthand notation would be 1:2:7 10 11, which defines the list
;   1 3 5 7 10 11.
;   <integer_list> is used to list device numbers in various TSDF files:
;   mdef, splitinfo, and mtimes
; <number_list> is the same as <integer_list>, but any real number can be
;   used to make a list of real numbers, not just integers.  Also, unlike
;   <integer_list>, <step> must always be explicitly written out, even when
;   <step>=1.  <number_list> is used for defining sweep and step parameter
;   ranges in ivdat files.
;
; <units> are used to define the units of a parameter, so they must make
;   physical sense.  Examples are 'V' for volts, 'mV' for millivolts,
;   'cm^2/V.s' for mobility (centimeter squared per volt second).  Unit
;   prefixes such as 'm' for milli, 'M' for mega must conform to SI
;   definitions.  The common ones are listed here for reference and are
;   part of the syntax:
;   'm' -- 1e-3 (milli)
;   'u' -- 1e-6 (micro)
;   'n' -- 1e-9 (nano)
;   'p' -- 1e-12 (pico)
;   'f' -- 1e-15 (femto)
;   'a' -- 1e-18 (atto)
;   'z' -- 1e-21 (zepto)
;   'k' -- 1e3 (kilo)
;   'M' -- 1e6 (mega)
;   'G' -- 1e9 (giga)
;   'T' -- 1e12 (tera)
;   'P' -- 1e15 (peta)
;   'E' -- 1e18 (exa)
;   'Z' -- 1e21 (zetta)
; decibels are always 'dB'
;
; <non_whitespace> is any of the basic non-whitespace characters except '#'
;   because '#' is used to denote a commment in some TSDF files.
; <text> is any string of characters, non-whitespace and whitespace.
; <whitespace> is 1 or more spaces only (no tabs or newlines).
; <EOL> stands for the end-of-line character, which is a newline in unix
;   (<newline>) or carriage-return and linefeed in DOS <CRLF>.
;
; TSDF supports algebraic equations, and the rules are given by the
; definitions for these:
;  <factor>
;  <exp>
;  <term>
;  <expr>
;  <function>
; Written this way, operator precedence is built into the syntax.
; Only a few functions are defined, but more can be added as needed.
;
; Other notation used:
;  [] denotes an optional component, eg. [<whitespace>] is optional whitespace.
;     optional components can be nested, eg. [ <text> [<EOL>] ]
;  + after a component denotes 1 or more of the component.
;  * after a component denotes 0 or more of the component.
;  | denotes a choice between the component to the left of the '|' and the
;     component to the right of the '|'.  Parentheses are used to control the
;     precedence in choice constructs; these constructs can be nested.
;  "" text between double quotes is the exact text used
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ***************
; * sessioninfo *
; ***************
;
; TSDF sessioninfo file syntax in Backus-Naur Form
;
<sessioninfo_file> ::= <session_name> <comment> <tsdf_version> <lab> <start_timestamp> <finish_timestamp> <system_name> <probecard> <operator_name> <test_type> <raw_data_path> <raw_data_format> <temperature> <DUT_type> <number_of_devices> <number_control_devices> <number_stress_meas_cycles> <cumulative_stress_time> <monitor_parameter_list> <stress_parameter_list> <iv_curve_flag> <predat_flag> <postdat_flag> <stress_type> <process_list> <product_list> <test_chip_list> <test_pattern_list> <module_list> <device_type_list> <lot_id_list> <wafer_id_list>
  <session_name> ::= "session:" [<whitespace>] <alphanumeric>+ <EOL>
  <comment> ::= "comment:" [<whitespace>] <text> <EOL>
  <tsdf_version> ::= "TSDF version:" [<whitespace>] <digit>+ "." <digit>+ ["." <digit>+] <EOL>
  <lab> ::= "lab: [<whitespace>] <text> <EOL>
  <start_timestamp> ::= "start time:" [<whitespace>] <day> "-" <month> "-" <year> " " <hour> ":" <minute> ":" <second> <EOL>
  <finish_timestamp> ::= "finish time:" [<whitespace>] [<day> "-" <month> "-" <year> " " <hour> ":" <minute> ":" <second>] <EOL>
    <day> ::= <digit><digit>
    <month> ::= "Jan"|"Feb"|"Mar"|"Apr"|"May"|"Jun"|"Jul"|"Aug"|"Sep"|"Oct"|"Nov"|"Dec"
    <year> ::= <digit><digit><digit><digit>
    <hour> ::= <digit><digit>
    <minute> ::= <digit><digit>
    <second> ::= <digit><digit>
  <system_name> ::= "system:" [<whitespace>] <text> <EOL>
  <probecard> ::= "probecard:" [<whitespace>] <alphumeric>+ <EOL>
  <operator_name> ::= "operator:" [<whitespace>] <text> <EOL>
  <test_type> ::= "test type:" [<whitespace>] ("HCI"|"NBTI"|"PBTI"|"BTI"|"GOI"|"Ramp"|"TDDB"|"EM"|"PID"|"OPL"|"HTOL"|"HAST"|"TMCL"|"TMSL"|<custom_test_type>)
    <custom_test_type> ::= <alphanumeric>+
  <raw_data_path> ::= "raw data path:" [<whitespace>] (<unix_path> "/" | <dos_path> "\" | <network_path> "\") <session_name> <EOL>
  <raw_data_format> ::= "raw data format:" [<whitespace>] ("TSDF"|"Keithley HCD"|"Keithley ACS"|"Keithley KTE"|"Agilent AD3"|"Qualitau Mira HCI"|"Qualitau Mira TDDB"|"Qualitau Mira EM"|"SM"|"Qualitau Mira BIP"|"Qualitau Infinity"|"CoreWafer SDR"|<custom_raw_data_format>) <EOL>
; ?* Aetrium, others *?
    <custom_raw_data_format> ::= <text>
  <temperature> ::= "temp (C):" [<whitespace>] <digit>+ ["." <digit>+] <EOL>
  <DUT_type> ::= "DUT:" [<whitespace>] ("package-level" | "wafer-level") <EOL>
  <number_of_devices> ::= "number of devices:" [<whitespace>] <digit>+ <EOL>
  <number_control_devices> ::= "control devices:" [<whitespace>] <digit>+ <EOL>
  <number_stress_meas_cycles> ::= "stress/measure cycles:" [<whitespace>] <digit>+ <EOL>
  <cumulative_stress_time> ::= "stress time (sec):" [<whitespace>] <number> [<whitespace> <number> <whitespace> <number>] <EOL>
  <monitor_parameters> ::= "monitor parameters:" [<whitespace>] <digit>+ [<whitespace> <parameter_list>] <EOL>
  <stress_parameters> ::= "stress parameters:" [<whitespace>] <digit>+ [<whitespace> <parameter_list>] <EOL>
    <parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <iv_curve_flag> ::= "IV curves:" [<whitespace>] ("yes"|"Yes"|"YES"|"no"|"No"|"NO") <EOL>
  <predat_flag> ::= "predat file:" [<whitespace>] ("yes"|"Yes"|"YES"|"no"|"No"|"NO") <EOL>
  <postdat_flag> ::= "postdat file:" [<whitespace>] ("yes"|"Yes"|"YES"|"no"|"No"|"NO") <EOL>
  <stress_type> ::= "stress type:" [<whitespace>] ("DC"|"AC") ["alternating"] <EOL>
  <process_list> ::= "process:" [<whitespace>] (<process_name>+|"??") <EOL>
    <process_name> ::= <non_whitespace>+ <whitespace>
  <product_list> ::= "product:" [<whitespace>] (<product_name>+|"??") <EOL>
    <product_name> ::= <non_whitespace>+ <whitespace>
  <test_chip_list> ::" [<whitespace>]test chip: " (<test_chip_name>+|"??") <EOL>
    <test_chip_name> ::= <non_whitespace>+ <whitespace>
  <test_pattern_list> ::" [<whitespace>]test pattern: " (<test_pattern_name>+|"??") <EOL>
    <test_pattern_name> ::= <non_whitespace>+ <whitespace>
  <module_list> ::= "module:" [<whitespace>] (<module_name>+|"??") <EOL>
    <module_name> ::= <non_whitespace>+ <whitespace>
  <device_type_list> ::= "device_type:" [<whitespace>] (<device_type_name>+|"??") <EOL>
    <device_type_name> ::= <non_whitespace>+ <whitespace>
  <lot_id_list> ::= "lot:" [<whitespace>] (<lot_id>+|"??") <EOL>
    <lot_id> ::= <non_whitespace>+ <whitespace>
  <wafer_id_list> ::= "wafer:" [<whitespace>] (<wafer_id>+|"??") <EOL>
    <wafer_id> ::= <non_whitespace>+ <whitespace>
;
; Notes on sessioninfo Content
; ----------------------------
; <session_name> can follow any naming convention convenient for the user.
;   An example of one possible convention:
;           <lot_id>_<dev_name>_<rel_test>_<increment>
;   concrete example: LOTX5S33_PMOS1p2V_NBTI_1, which would denote a
;   stress session performing NBTI on 1.2 V PMOS devices from lot LOTX5S33
;   Alternately, the <session_name> could be automatically generated, for
;   instance, as a random string.  Such a situation could occur if using
;   some sort of test floor automation software.
; <comment> is any text to capture test objective, give more context for testing
;   etc.
; <tsdf_version> is a new field required for TSDF revision 0.6.1 and above, and
;   since it was not specified before then, it may not exist in older pre-version
;   0.6.1 TSDF sessioninfo files.  All previous TSDF updates are, by construct,
;   optional, because the program reading the TSDF would have to see what is
;   available and parse as necessary.
; <lab> is an optional (but highly recommended) field for the name of the lab
;   or organization that performed the testing.
; <probecard> captures probecard ID for wafer-level testing with probecards.
; <finish_timestamp> can be empty if the stress session is still running.
;   This is useful for the situation in which a stress control program
;   writes TSDF directly.  In this case, analysis software can analyze the
;   stress session while it is running, or test floor monitoring software
;   can determine which test systems are presently running a stress session.
; <test_type> can be any reliability failure mechanism test, but is formally 
;   defined for the following:
;      HCI: Hot-Carrier Injection
;      NBTI: Negative-Bias Temperature Instability
;      PBTI: Positive-Bias Temperature Instability
;      BTI: Bias Temperature Instability (generic, could be mobile-ion test)
;      GOI: Vramp or Jramp on gate oxide capacitors
;      Ramp: Vramp or Jramp on capacitors other than gate oxide capacitors, or
;        Jramp on contact or via chains or other interconnect components.
;      TDDB: Time-Dependent Dielectric Breakdown
;      EM: Electromigration
;      SM: Stress migration
;      PID: Process-Induced Damage (eg. antenna damage characterization)
;      HTRB: High Temperature Reverse Bias test (typically on power transistors)
;      HTGB: High Temperature Gate Bias test (typically on power transistors)
;      OPL: operating life test on products, including dynamic OPL
;      HTOL: high-temperature operationg life test
;      HAST: highly accelerated stress test (high temperature and humidity)
;      TMCL: temperature cycle test
;      TMSL: temperature storage life
;    Many others could be defined.
;    ?* How far do we go with this pre-defined list of tests *?
; <raw_data_path> and <raw_data_format> are informational, as any analysis
;   software would not use this information directly, but a user's custom
;   database management software could use it.  This means any text the 
;   user finds useful may be used for these entries.  In the case of the
;   test system writing TSDF directly, the entry to <raw_data_format>
;   should be "TSDF".
; <unix_path>, <dos_path>, and <network_path> follow the syntax of those
;   respective operating systems.  Remote machines that hold the data may
;   be optionally specified as needed.  Again, this is informational only.
;   <directory_name> would be any valid directory name in the listed
;   operating systems.
; <temperature> is given in Celsius and the units are put there just so
;   no one forgets.
; <number_of_devices> gives the total number of devices in the experiment,
;   both stressed devices and control devices.
; <number_control_devices> gives the number of control devices.  Control
;   devices are DUTs that are not stressed, but have monitor parameters
;   measured at each stress interval.
; <number_stress_meas_cycles> Is the number of stress/measurement cycles.
;   If equal to zero, it implies t=0 data only.  The mtimes file should 
;   reflect that, too, as should the <cumulative_stress_time> entry.
; <cumulative_stress_time> will be the last recorded stress time in the mtimes
;   file, or if DUTs have different cumulative stress times, it will
;   list the min, max and median cumulative stress time of all DUTs.
; <monitor_parameters> gives the number of parameters used to monitor
;   degradation, that is, measured after the stress bias is removed (the 
;   "measure" part of a stress/measure cycle).  Optionally, the names of the
;   monitor parameters can be given here.  If present, the list should match
;   the list of monitor parameters in the second line of the mdat file.  If
;   the number of monitor parameters is zero, there should be no mdat file.
; <stress_parameters> gives the number of parameters measured during stress,
;   that is, measured while stress biases are applied (during the "stress"
;   part of a stress/measure cycle).  Optionally, the names of the stress
;   parameters can be given here.  If present, the list should match the list
;   of stress parameters in the second line of the sdat file.  If the number
;   of stress parameters is zero, there should be no sdat file.
; <stress_type> contains the type of stress, DC or AC, and indicates if 
;   the stress is the same for all stress/measurement cycles, or has different
;   values for different cycles.  The latter is indicated with the 
;   keyword "alternating" after the DC or AC entry.  The actual stress is
;   defined in the stressinfo file.
;
; The remaining list entries show the unique set of values for each information
; type (process, lot, wafer, device, etc) for the DUTs.  This information
; comes from the devinfo file.  It is a convenient way to see what material 
; has been stressed for a given stress session.  It is possible that certain 
; device information is missing.  Missing information is denoted with the 
; double question mark ("??" without the quotes), and that denotation is 
; transferred to this list.  See the devinfo file syntax and documentation
; for more information.
;
; The reports list entry is used to hold the name of reports (or a link
; to the reports) that have used the data in the stress session.  If no
; reports have been generated, the entry remains blank.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ***********
; * devinfo *
; ***********
;
; TSDF devinfo file syntax in Backus-Naur Form
;
<devinfo_file> ::= <session_line> <devinfo_header_line> <device_info>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <devinfo_header_line> ::= "#index process fab route product testchip testpattern module structure devtype lot wafer sitexy socket cntl build package_id misc_info" <EOL>
  <device_info> ::= <devinfo_line> | (<devinfo_line> <EOL> <device_info>)
    <devinfo_line> ::= <dev_index> <process> <whitespace> <fab> <whitespace> <route> <whitespace> <product> <whitespace> <testchip> <whitespace> <testpattern> <whitespace> <module> <whitespace> <structure> <whitespace> <device_type> <whitespace> <lot> <whitespace> <wafer> <whitespace> <site> <whitespace> <socket> <whitespace> <control_flag> <whitespace> <build> <whitespace> <package_id> [<whitespace> <misc_info>]
      <dev_index> ::= <digit>+
      <process> ::= <non_whitespace>+ | "??"
      <fab> ::= <non_whitespace>+ | "??"
      <route> ::= <non_whitespace>+ | "??"
      <product> ::= <non_whitespace>+ | "??"
      <testchip> ::= <non_whitespace>+ | "??" | "N/A"
      <testpattern> ::= <non_whitespace>+ | "??"
      <module> ::= <non_whitespace>+ | "??"
      <structure> ::= <digit>+ | <alphanumeric>+ | "??"
      <device_type> ::= <non_whitespace>+ | "??"
      <lot> ::= <non_whitespace>+ | "??"
      <wafer> ::= <non_whitespace>+ | "??"
      <site> ::= [-]<digit>+ "," [-]<digit>+ | "??"
      <socket> ::= <non_whitespace>+ | "??" | "N/A"
      <control_flag> ::= "0" | "1"
      <build> ::= <non_whitespace>+ | "??" | "N/A"
      <package_id> ::= <non_whitespace>+ | "??" | "N/A"
      <misc_info> ::= <text>
;
; Notes on devinfo Content
; ----------------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <dev_index> is the index number of the device, 1 through N for N devices.
;   The <dev_index> is also put at the front of each data row in *dat files
;   (mdat,sdat, predat, postdat) for mapping the data to a device.
; <process> is the fabrication process name.
; <fab> is the name of the fabrication facility that produced the material
;   that the DUT came from.
; <route> is the name of the particular fab route, if applicable.  For example,
;   this is where one would specify the number of metal layers, or the use of
;   extra masks and process steps to define optional components, for processes
;   that support such options.  Typically, this would be some fab-specific
;   code to denote the exact fab route, or simply for example "2LM" to denote
;   a 2 level metal variation of a given process.
; <product> is the product name, used if the test was on a product chip, or
;   or the reliability test structure stressed came from a drop-in die or
;   scribeline.  If the material came from a test chip, <product> will be
;   the same as the test chip name.
; <testchip> is the test chip name, if the material came from a test chip.
;   If the material came from a product, <testchip> will be "N/A" for "Not
;   applicable."
; <testpattern> is the name of the test pattern, or group of modules.
;   There are situations in which multiple copies of a test pattern are
;   placed within a stepper field.  In this case, the test pattern name
;   should include extra characters to differentiate the different
;   instances of the test pattern.  This should follow any convention used
;   in the test chip documentation.  For example, if there are two copies
;   of test pattern "TP123" in a test chip, the <testpattern> should read
;   for example "TP123_A" or "TP123_1" or whatever, to show that the
;   first (or A_th) instance of the test pattern was used.
; <module> is the name of the module, typically a group of test structures
;   in a pad ring.
; <structure> is the test structure number as found in the module
;   documentation.  If no number is given for the structure, use for the
;   number the order in which the structure appears in the module
;   documentation (assuming it is shown as a list).
;   Alternatively, use a structure name as it appears in any documentation
;   of the module or test structure.
; <device_type> is the component/device name, eg. "5VNMOS" or "Metal1Res" etc.
;   It can be the component's CAD name, eg. RM1 for a metal 1 resistor.
; <lot> is the lot ID of the material.
; <wafer> is the wafer ID of the material.
; <site> is the X,Y index of the die from which the material came.  Site 0,0
;   could be the center of the wafer, so negative indices are allowed.  
;   Ancillary documentation should be given to denote the location of site
;   0,0 to allow wafermapping given the site information in this file.
; <socket> is the socket number in the test system.  For package-level testing
;   only, so if this stress session is at the wafer-level, <socket> would
;   be "N/A" for "Not Applicable."  If the stress session is package-level
;   but socket information is not known, <socket> is "??".
; <control_flag> is to label control devices. <control_flag> equals 1 if 
;   the device was not stressed, but monitor parameters were taken to 
;   monitor degradation.
; <build> is the name of the build for package-parts, if such information
;   is available.  As with <socket> and <package_id>, if the stress session
;   is wafer-level, <build> will be "N/A".  If the stress session is for
;   package-level, and the information is not available, <build> is "??".
;   In future extensions of TSDF, build information may be included in
;   a buildinfo file that would capture the package bill of materials
;   (mold compound, lead frame, DAP, wire bond, etc) and the assembly
;   site, which is important information for product reliability testing.
; <package_id> is the package ID, if such information is available.  For
;   wafer-level stress sessions, <package_id> is "N/A".  For package-level
;   stress session in which the package ID is not known, <package_id> is "??".
; <misc_info> is any other optional information the user wants to capture.
;   It can be used to list the device parameters that are not captured
;   anywhere else.  For example, for MOSFET devices, device parameters
;   are channel length, channel width, orientation, number of gate fingers,
;   butted or non-butted source/bulk contacts, pad assignments, etc.
;
; Note that detailed device information is not kept in the devinfo file.
; Only enough information (test pattern::module::number) is given, 
; so that all the device information can be found from test structure 
; documentation.  This partitioning of the DUT information has been done to
; keep the devinfo file clean and easy to parse.  It is not possible to 
; anticipate every type of device that may be tested, so it is not possible
; to define the exact parameters needed to define a device.  If users
; want to keep more detailed device information in the devinfo file, they 
; can put them in the miscellaneous column, which can be of any length.
;
; Note also that because the devinfo file uses whitespace as a delimiter,
; all entries must contain no whitespace, except the "misc_info" field,
; which can be any text of any length.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; **************
; * stressinfo *
; **************
;
; TSDF stressinfo file syntax in Backus-Naur Form
;
<stressinfo_file> ::= <session_line> [<data_order>] <bias_names> <stressinfo>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <data_order> ::= "#data order:" [<whitespace>] ("default"|"time")|"device"|("hybrid" <whitespace> <hybrid_block_size>) <EOL>
    <hybrid_block_size> ::= <digit>+ <whitespace> <digit>+
  <bias_names> ::= "#Biases:" [<whitespace>] <bias_list> <EOL>
    <bias_list> ::= <bias_name>+
      <bias_name> ::= <alphanumeric>+ ["[" <units> "]"] <whitespace>
  <stressinfo> ::= <stressinfo_line> | (<stressinfo_line> <EOL> <stressinfo>)
    <stressinfo_line> ::= [<whitespace>] <bias_value> | (<bias_value> <whitespace> <stressinfo_line>)
      <bias_value> ::= <number>
;
; Notes on stressinfo Content
; ---------------------------
; The stressinfo file is ordered similarly to the sdat file, as there
; can be time=0 stress biases only (for non-alternating stress), or blocks of
; stress biases for each stress interval.  Also, the ordering of stress biases
; may be by time order or device order, same as in the mdat and sdat files.
;
; <session_name> is the same session name as found in the sessioninfo file.
; <bias_names> is the list of stress biases that have values in the stressinfo
;   file.  They are ordered the same as the data columns.  In other words,
;   the <bias_names> contains the column names of the bias values in the 
;   stressinfo file.
; <data_order> is optional for the default order or when only time=0 stress
;   biases are included (for constant bias stress).
; <hybrid_block_size> is a list of 2 integers, the first being the number
;   of devices in a subblock and the second being the number of time point
;   data for those devices.  Time points are 1 plus the number of 
;   stress/measure cycles to include time zero data.
;
; For alternating stress, bias values are ordered not only by column, but 
; also by device and monitor times.  There are several possible orderings.
; This added complexity is to allow different types of test systems to 
; output TSDF directly by simply appending to existing TSDF: no need to
; rewrite entire files.  See the description of data ordering in the mdat
; section of this document for details.  It is recommended that the same data
; ordering be used in the mdat, sdat, and stressinfo file, but is not
; required.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; *************
; * splitinfo *
; *************
;
; TSDF splitinfo file syntax in Backus-Naur Form
;
<splitinfo_file> ::= <splitinfo_lot_line> <splitinfo>
  <splitinfo_lot_line> ::= "#splitinfo" <whitespace> [<lot_list>] <EOL>
    <lot_list> ::= <lot_name>+
      <lot_name> ::= <alphanumeric>+ <whitespace>
  <splitinfo> ::= <splitinfo_block> | (<splitinfo_block> <splitinfo>)
    <splitinfo_block> ::= <lot_id_line> <split_list> <wafer_split_info> "#"
      <lot_id_line> ::= "lot" [<whitespace>] "=" [<whitespace>] <lot_name> <EOL>
      <split_list> ::= <split_info_line> | (<split_info_line> <split_list>)
        <split_info_line> ::= "split" [<whitespace>] "=" [<whitespace>] <split_description> <EOL>
          <split_description> ::= """ <text> """
      <wafer_split_info> ::= <wafer_split_line> | (<wafer_split_line> <wafer_split_info>)
        <wafer_split_line> ::= "wafers" [<whitespace>] "=" [<whitespace>] "[" <wafer_list> "]" [<whitespace>] "=" [<whitespace>] <split_correspondence> <EOL>
          <wafer_list> ::= <integer_list>
          <split_correspondence> ::= ('+'|'-'|<whitespace>)+
;
; Notes on splitinfo Content
; ---------------------------
; The splitinfo file contains split information for one or more lots.
; Information from any lot is allowed, but to be useful, the file should
; contain lot information for those lots listed in the devinfo file.  
; Splits are by wafer, which is standard procedure in the semiconductor 
; industry.  All wafers of a lot may be listed, or just the wafers relevant
; to the stress session. 
;
; Note there is no session name information in this file.  This reflects
; the utility of the splitinfo file beyond any single stress session.
; A lot may have multiple measurements performed on it, so multiple stress
; sessions could use the same lot split information file.
;
; In the splitinfo file, split information for each lot is grouped 
; together in a separate block (<splitinfo_block>).
; <splitinfo_block> contains split information for a particular lot.  This
;   block of information starts with a line containing the lot id,
;   corresponding to <lot_id_line>, and ends with a '#' on a separate row.
; <lot_id_line> example: "lot=XX34056G"
;   Next, splits are listed with a descriptive phrase, one split per row,
;   each row corresponding to a <split_info_line>.
; <split_info_line> example: 'split="2e13 nLDD dose"'.  Note that splits
;   can be enumerated explicitly, useful for reading the file for a large
;   number of splits.  An example:
;      split1="2e13 nLDD dose"
;      split2="1e13 nLDD dose (POR)"
;      split3="Oxide pre-clean A002"
;      split4="Oxide pre-clean CL033"
;   Finally, wafers are assigned splits in <wafer_split_line> rows.
; <wafer_split_line> example: wafers=[1 2 3] = +--+
;   which denotes that wafers 1, 2, and 3 are part of split1 and split4, and
;   not part of split2 or split3, of a 4-way split experiment.  The +/- string
;   must have the same number of characters as the number of splits.
;   Whitespace is allowed between '+' and '-' characters.  The recommended
;   format is to group characters together in groups of four.
;   Example: ++-- -+-+
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; *************
; * waferinfo *
; *************
;
; TSDF waferinfo file syntax in Backus-Naur Form
;
<waferinfo_file> ::= <session_name> <notch_or_flat> <notch_location> <xy_origin_location> <reticle_step_file_path> <waferscribe_logical_wafer_number_ref>
  <session_name> ::= "session:" [<whitespace>] <alphanumeric>+ <EOL>
  <notch_or_flat> ::= "notch or flat:" [<whitespace>] "notch" | "flat" <EOL>
  <notch_location> ::= "notch/flat location:" [<whitespace>] "bottom" | "top" | "left" | "right" <EOL>
  <xy_origin_location> ::= ("LL" | "Lower Left") | ("LR" | "Lower Right") | ("UL" | "Upper Left") | ("UR" | "Upper Right") <EOL>
  <reticle_step_file_path> ::= "Reticle stepping file:" [<whitespace>] (<unix_path> "/" | <dos_path> "\" | <network_path> "\") <reticle_step_filename> <EOL>
    <reticle_step_filename> ::= <alphanumeric>+ <EOL>
  <waferscribe_logical_wafer_number_ref> ::= <waferscribe_ref_start> <waferscribe_ref> <waferscribe_ref_end>
    <waferscribe_ref_start> ::= "Waferscribe - Logical Wafer Number Table" <EOL> "WaferID" "ScribeID" <EOL>
      <waferscribe_ref> ::= <waferscribe_ref_line> | <waferscribe_ref_line> <EOL> <waferscribe_ref>
        <waferscribe_ref_line> ::= <digit>+ <whitespace> <alphanumeric>+
    <waferscribe_ref_end> ::= "# End Waferscribe Table
;
; Notes on waferinfo Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <notch_or_flat> is 'notch' or 'flat' to support old wafers with flats
; <reticle_step_file_path> and <reticle_step_filename> give the location of any reticle stepping distance map file that 
;    is relevant for the dataset.
; <waferscribe_logical_wafer_number_ref> is a table containing the mapping of logical wafer numbers to waferscribes, if such
;    data is available.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; ********
; * mdef *
; ********
; 
; TSDF mdef file syntax in Backus-Naur Form
; 
<mdef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= <mdef_block> | (<mdef_block> <EOL> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <EOL> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" [<whitespace>] <parameter_def_list> [<whitespace> <units_string>] [<whitespace> <parameter_desc>]
          <parameter_name> ::= <alphanumeric>+
          <parameter_def_list> ::= <parameter_def> | <parameter_def> <whitespace> <parameter_def_list>
            <parameter_def> ::= "bias="<bias_def_list> | "equ="<parameter_equ> | "cmp="<parameter_cmp>
              <bias_def_list> ::=  <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
                <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
                  <bias_name> ::= <alphanumeric>+
                  <bias_value> ::= <number>
              <parameter_equ> ::=  <expr> | <whitespace> <expr>
                    <factor> ::= <variable> | <iv_reference>
                      <variable> ::= "<" <parameter_name> ">"
                      <iv_reference> ::= "'" <iv_label> "'"
                         <iv_label> ::= "IV=" <alphanumeric>+
              <parameter_cmp> ::= <bias_name> "@" <bias_name> <cmp_op> <expr>
                <cmp_op> ::= "==" | "<" | "<=" | ">" | ">=" | "!="
          <parameter_desc> ::= """ <text> """
          <units_string> ::= "units=" <units>
;
; Notes on mdef Content
; ---------------------
;   mdef has had a major upgrade in Rev 0.7, based on inputs from Keithley
;   back in 2013, and only now addressed.  Prior to Rev 0.7, mdef parameter
;   definitions consisted of bias values only, fine for spot measurements,
;   but not useful for more complex parameters such as extrapolated Vt (Vtx),
;   or transconductance (Gm), and also not useful for parameters based on
;   some threshold, like time to breakdown (Tbd) in TDDB defined by the
;   current through the capacitor test structure reaching a certain value.  
;   Support for these new types of parameter definitions required a more
;   complicated syntax, which is outlined below.
; <session_name> is the same session name as found in the sessioninfo file.
; <mdefs> is divided into blocks (<mdef_block>) of parameter definitions, each 
;   block containing parameter definitions for a set of devices with 
;   those monitor parameters.  If all devices have the same mdefs, there is
;   only one mdef block in the file, and the <device_line> line is optional.
;   If every device has a different set of parameter definitions, there will
;   be as many mdef blocks as there are devices.  Each block will have a
;   <device_line> line at its start to denote the device number that 
;   corresponds to the mdefs in that block.  In stress sessions where one
;   or more subsets of devices have the same mdefs, there will be mdef blocks
;   for each subset.
; <device_line> lists the device numbers for the mdef block.
; <mdef_line> consists of the <parameter_name> followed by the parameter 
;   definition 
; <parameter_def>, parameter definition can take two forms:
;       1. bias definitions
;       2. optional bias definitions plus a description, such as an equation
;              or similar
;   Bias definitions have the format <name>=<value> or 
;   <name>[<units>]=<value> if the user wants to specify the units.  Units
;   are sometimes optional because for <name> starting with "V" or "v", the
;   units are assumed to be Volts, and for <name> starting with "I" or  "i",
;   the units are assumed to be Amperes.  The same holds true for
;   <parameter_name>:
;   starting with "V" or "v" implies units of volts, and starting with
;   "I" or "i" implies units of amperes.  The optional <units_string>
;   definition specifies the parameter units if needed.
;
;   Since parameters can be calculated from other parameters or extracted
;   from IV curves, or even defined by a current level or change of
;   slope in a curve (example: Vbd of a Vramp test or TDDB), another way
;   to specify parameters is needed.  This is the role of the parameter
;   definition description (<parameter_def_desc>).  This description does
;   not try to ensure an equation is written correctly, so it can be
;   treated just like any text.  There are several conventions that should
;   be followed for consistency over mdef files from any source.  
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * mtimes *
; **********
; 
; TSDF mtimes file syntax in Backus-Naur Form
; 
<mtimes_file> ::= <session_line> [<time_units>] <mtimes>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <time_units> ::= "#units: sec" <EOL>
  <mtimes> ::= <mtimes_block> | (<mtimes_block> <EOL> <mtimes>)
    <mtimes_block> ::= [<device_line>] <device_mtimes>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mtimes> ::= <mtimes_line> | (<mtimes_line> <EOL> <device_mtimes>)
        <mtimes_line> ::= [<whitespace>] <time_index> <whitespace> <mtimes_value>
          <time_index> ::= <digit>+
          <mtimes_value> ::= <pos_number>
;
; Notes on mtimes Content
; -----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <time_units> is informational, as TSDF requires all time data to be in
;   units of seconds.
; <mtimes> is divided into blocks (<mtimes_block>) of mtime values, each 
;   block containing mtimes values for a set of devices with those mtimes.
;   If all devices have the same mtimes, there is only one mtimes block in 
;   the file, and the <device_line> line is optional.  If every device has a
;   different set of mtimes, there will be as many mtimes blocks as there
;   are devices.  Each block will have a <device_line> line at its start to
;   denote the device number that corresponds to the mtimes in that block.
;   In stress sessions where one or more subsets of devices have the same 
;   mtimes, there will be mtimes blocks for each subset.
; <device_line> lists the device numbers for the mtimes block.
; <mtimes_line> consists of two numbers: an index number (which starts at 0
;   for time=0), and the cumulative stress time at the end of that stress
;   interval, in seconds.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * stimes *
; **********
; 
; TSDF stimes file syntax in Backus-Naur Form
; 
<stimes_file> ::= <session_line> [<time_units>] <stimes>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <time_units> ::= "#units: sec" <EOL>
  <stimes> ::= <stimes_block> | (<stimes_block> <EOL> <stimes>)
    <stimes_block> ::= [<device_line>] <device_stimes>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_stimes> ::= <stimes_line> | (<stimes_line> <EOL> <device_stimes>)
        <stimes_line> ::= [<whitespace>] <time_index> <whitespace> <stimes_value>
          <time_index> ::= <digit>+
          <stimes_value> ::= <pos_number>
;
; Notes on stimes Content
; -----------------------
; stimes is an optional file that is useful in situations where the test
;   program monitors stress parameters at times different than the times
;   listed in the mtimes file.  An example would be if the stress parameters
;   are monitored semi-continuously.
; If the stimes file exists, the stress paraemters in the sdat file will
;   correspond to times in the stimes file.  If the stimes files does not
;   exist, the stres parameters in the sdat file will correspond to times in
;   the mtimes file.
; <session_name> is the same session name as found in the sessioninfo file.
; <time_units> is informational, as TSDF requires all time data to be in
;   units of seconds.
; <stimes> is divided into blocks (<stimes_block>) of stime values, each 
;   block containing stimes values for a set of devices with those stimes.
;   If all devices have the same stimes, there is only one stimes block in 
;   the file, and the <device_line> line is optional.  If every device has a
;   different set of stimes, there will be as many stimes blocks as there
;   are devices.  Each block will have a <device_line> line at its start to
;   denote the device number that corresponds to the stimes in that block.
;   In stress sessions where one or more subsets of devices have the same 
;   stimes, there will be stimes blocks for each subset.
; <device_line> lists the device numbers for the stimes block.
; <stimes_line> consists of two numbers: an index number (which starts at 0
;   for time=0), and the cumulative stress time at the end of that stress
;   interval, in seconds.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ********
; * mdat *
; ********
;
; TSDF mdat file syntax in Backus-Naur Form
;
<mdat_file> ::= <session_line> [<data_order>] <mdat_header_line> <monitor_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <data_order> ::= "#data order:" [<whitespace>] ("default"|"time")|"device"|<hybrid_data_order>) <EOL>
    <hybrid_data_order> ::= "hybrid" <whitespace> [<hybrid_number_of_devices> [<hybrid_number_of_time_points>] ]
      <hybrid_number_of_devices> ::= <digit>+
      <hybrid_number_of_time_points> ::= <digit>+
  <mdat_header_line> ::= "#monitors:" [<whitespace>] "dev_index" <whitespace> <monitor_parameter_list> <EOL>
    <monitor_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <monitor_data> ::= <time_device_data_block> | <hybrid_data_block>+
    <time_device_data_block> ::= <monitor_data_line>+
    <hybrid_data_block> ::= ["#" [<whitespace>] <hybrid_data_order> <EOL>] <monitor_data_line>+
      <monitor_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
        <dev_index> ::= <digit>+
        <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
          <test_data> ::= <number>
;
; Notes on mdat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <data_order> defines the "data order" used in the mdat file.  Data order
;   can be:
;       "time" (or "default")
;       "device"
;       "hybrid"
;   <data_order> is optional for the "time" (default) data order.  For the
;   hybrid data ordering, if the same number of devices are stressed
;   for each site, then the <hybrid_number_of_devices> integer can be written
;   here.  In addition, if the same number of time points will be measured for
;   all devices, then the <hybrid_number_of_time_points> integer can also be
;   written.  If <hybrid_number_of_devices> is written on this line,
;   there is no need for embedded <hybrid_data_order> lines in each
;   <hybrid_data_block>.  Note that the optional <hybrid_number_of_time_points>
;   is redundant, as once the number of devices is known for each site,
;   the number of time points is specified in the mtimes file for each device.
; <mdat_header_line> conains <monitor_parameter_list>, which is the list of
;   monitor parameters that have data in the mdat file.  They are ordered
;   the same as the data columns.  In other words, the monitor parameter
;   list contains the column names of the data in the mdat file.  The same
;   list will be optionally found in the sessioninfo file on the
;   "monitor_parameters" row.
; <monitor_data> is ordered not only by column, but also by device and
; monitor times.  There are several possible orderings.  This added
; complexity is to allow different types of test systems to output TSDF
; directly by simply appending to existing TSDF: no need to rewrite entire
; files.  This will become clear with the examples given below.
;
; For directly plotting degradation curves for each device in a dataset,
; the "device" order is the easiest to parse, as data will be organized
; in device blocks, each block being a set of mtimes for a specific device.
;
; For directly plotting boxplots or distributons of sets of devices from
; a single monitor time point, the "time" order would be the easiest to parse.
;
; For the hybrid data order with different number of devices in different
; sites (i.e. different <hybrid_data_block>), the <hybrid_data_order> is
; embedded in the <hybrid_data_block> for each site, and it must include
; the <hybrid_number_of_devices> entry.
;
; Monitor data parameters can be different for different devices in mdat.
; If this is the case, the <monitor_parameter_list> will include all the
; monitor parameters for all devices, and data padding (see the next
; paragraph) will be needed.
;
; Data points must sometimes be added to keep the data block the same
; size, or the number of columns the same.  Padded data is denoted by the
; value <padding_data>.  Testers could also output data with error
; information embedded in the values.  This data may be incorporated into
; the mdat file for later diagnostics etc, or use the default value 
; <bad_data> for bad data.
;
; Each data line (<monitor_data_line>) begins with the <dev_index> of the 
; device associated with that data row, then data corresponding each column
; defined in the <monitor_parameter_list>, with padding as needed (see above).
; The <dev_index> for each device is given in the devinfo file and is
; essentially the index into the devinfo table.
;
; ***********************
; Order by Time (Default)
; ***********************
; The default ordering is in blocks of stress/measure cycles, each block 
; containing data for a given stress/measure cycle for all devices, each
; device's data is in a separate row.  The order of devices, i.e. rows, 
; within a block is determined by the order of devices found in the 
; devinfo file.
;
; This format is most convenient for test systems that do a stress session
; on a single DUT or set of DUTs in parallel, for example a set of packaged
; parts, or a single touchdown on a wafer-level test system.  Note that
; all DUTs must have the same number of time points (time zero plus the 
; number of stress/measure cycles).  If they don't, padding data must be 
; added to devices with a smaller number of stress/measure cycles.  Padding
; data is given by the value <padding_data>.
;
; The order of the stress/measure cycle blocks is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L devices and M stress/measure
; cycles:
;      ------------------------------------------
;      |                                        |
;      |      Time=0, Devices 1 through L       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t1, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t2, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Time=tM, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;
; Here's what the mdat file would look like in detail for L devices, 
; N monitor parameters (aka mparams), and M stress/measure cycles:
; #session: <session_name>
; #data order: time
; #monitors: <mparam_name1> <mparam_name2> ... <mparam_nameN>
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev3_t0_mparam1 data_dev3_t0_mparam2 ... data_dev3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev3_t1_mparam1 data_dev3_t1_mparam2 ... data_dev3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
; data_dev3_tM_mparam1 data_dev3_tM_mparam2 ... data_dev3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
;
; ***************
; Order by Device
; ***************
; Another way to accomodate DUTs with different numbers of stress/measure
; cycles is to order the data in blocks of devices, each block containing
; data for a given device for each stress/measure cycle.  The order of
; data blocks is given by the order of devices found in the devinfo file.
;
; This format is most convenient for a stress session on a single DUT only,
; but stepped across several devices, i.e stressing in series.  An example 
; of such a stress would be a fast WLR test on a single component over
; many sites over many wafers.
;
; The order of the stress/measure cycles is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L devices and M stress/measure
; cycles (although each device could actually have different numbers of
; stress/measure cycles; such information would be found in the mtimes
; file):
;      ------------------------------------------
;      |                                        |
;      |      Device 1, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 2, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 3, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Device L, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;
; Here's what the mdat file would look like in detail for L devices, 
; N monitor parameters, and M stress/measure cycles:
; #session: <session_name>
; #data order: device
; #monitors: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev1_t2_mparam1 data_dev1_t2_mparam2 ... data_dev1_t2_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev2_t2_mparam1 data_dev2_t2_mparam2 ... data_dev2_t2_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
; data_devL_t3_mparam1 data_devL_t3_mparam2 ... data_devL_t3_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
;
; ************
; Hybrid Order
; ************
; Of course, many WLR tests that step over many sites (and possibly
; many wafers) may also stress several devices in parallel during a 
; single touchdown.  Such a hybrid parallel/series type of stress session
; can be accomodated using the format that is a hybrid of the previous 
; two formats.
;
; Note that for the hybrid format, all devices within the same site must
; have the same number of time points (M+1 in this example).  If devices
; have less, they need to be padded with <padding_data> to fill out the
; number of rows and columns.  The number of time points could be different
; for different sites.  The number of time points is found in the mtimes
; file.
;
; Here's a block diagram of the ordering for S sites probed in series, 
; each site stressing L devices in parallel for M stress/measure cycles:
;
;  --------------------------------------------------
;  | Site 1 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices 1 through L       |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;  --------------------------------------------------
;  | Site 2 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices L+1 through 2*L   |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;  --------------------------------------------------
;  | Site S stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=0, Devices (S-1)*L+1 through S*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t1, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t2, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=tM, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;
; Here's what the mdat file would look like in detail for S sites probed
; in series, each site stressing L devices in parallel, N monitor parameters,
; and M stress/measure cycles (L below would be replaced by an integer).
; Note that because L is the same for all sites, the data order line
; (the one that starts with "#data order:") could contain the L value,
; and the embedded "# hybrid L" lines could be removed.  The sdat file
; example for the hybrid data order shows this alternative format.  Here
; is the example mdat file:
; #session: <session_name>
; #data order: hybrid
; #monitors: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; # hybrid L
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev3_t0_mparam1 data_dev3_t0_mparam2 ... data_dev3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev3_t1_mparam1 data_dev3_t1_mparam2 ... data_dev3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
; data_dev3_tM_mparam1 data_dev3_tM_mparam2 ... data_dev3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
; # hybrid L
; data_devL+1_t0_mparam1 data_devL+1_t0_mparam2 ... data_devL+1_t0_mparamN
; data_devL+2_t0_mparam1 data_devL+2_t0_mparam2 ... data_devL+2_t0_mparamN
; data_devL+3_t0_mparam1 data_devL+3_t0_mparam2 ... data_devL+1_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_t0_mparam1 data_dev2*L_t0_mparam2 ... data_dev2*L_t0_mparamN
; data_devL+1_t1_mparam1 data_devL+1_t1_mparam2 ... data_devL+1_t1_mparamN
; data_devL+2_t1_mparam1 data_devL+2_t1_mparam2 ... data_devL+2_t1_mparamN
; data_devL+3_t1_mparam1 data_devL+3_t1_mparam2 ... data_devL+3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_t1_mparam1 data_dev2*L_t1_mparam2 ... data_dev2*L_t1_mparamN
; data_devL+1_tM_mparam1 data_devL+1_tM_mparam2 ... data_devL+1_tM_mparamN
; data_devL+2_tM_mparam1 data_devL+2_tM_mparam2 ... data_devL+2_tM_mparamN
; data_devL+3_tM_mparam1 data_devL+3_tM_mparam2 ... data_devL+3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_tM_mparam1 data_dev2*L_tM_mparam2 ... data_dev2*L_tM_mparamN
; # hybrid L
; data_dev2*L+1_t0_mparam1 data_dev2*L+1_t0_mparam2 ... data_dev2*L+1_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev3*L_tM_mparam1 data_dev3*L_tM_mparam2 ... data_dev3*L_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; # hybrid L
; data_dev(S-1)*L+1_t0_mparam1 data_dev(S-1)*L+1_t0_mparam2 ... data_dev(S-1)*L+1_t0_mparamN
; data_dev(S-1)*L+2_t0_mparam1 data_dev(S-1)*L+2_t0_mparam2 ... data_dev(S-1)*L+2_t0_mparamN
; data_dev(S-1)*L+3_t0_mparam1 data_dev(S-1)*L+3_t0_mparam2 ... data_dev(S-1)*L+3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_t0_mparam1 data_devS*L_t0_mparam2 ... data_devS*L_t0_mparamN
; data_dev(S-1)*L+1_t1_mparam1 data_dev(S-1)*L+1_t1_mparam2 ... data_dev(S-1)*L+1_t1_mparamN
; data_dev(S-1)*L+2_t1_mparam1 data_dev(S-1)*L+2_t1_mparam2 ... data_dev(S-1)*L+2_t1_mparamN
; data_dev(S-1)*L+3_t1_mparam1 data_dev(S-1)*L+3_t1_mparam2 ... data_dev(S-1)*L+3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_t1_mparam1 data_devS*L_t1_mparam2 ... data_devS*L_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_tM_mparam1 data_devS*L_tM_mparamS ... data_devS*L_tM_mparamN
;
; Note one more aspect of the hybrid data ordering. In many wafer level
; test programs, each site would contain multiple modules tested in
; sequence.  For example, each site testing might start off with a simple
; probecheck, which is a measure of the parasitic resistance in the probes
; and probe pads and would have nothing to do with the subsequent reliability
; testing of other modules/devices in the site.  This is not a issue for
; TSDF, as TSDF requires a single test_type in a dataset.  Test programs
; that have probechecks and/or multiple test_types create output that would
; by definition have to be converted to multiple TSDF stress sessions.  This
; could be done at the test system level, if the test shell supports creation
; of multiple data files from a run.  If not, the conversion program from
; the native test sysem format to TSDF would have to account for the
; multiple test_types in the original dataset.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ********
; * sdat *
; ********
;
; TSDF sdat file syntax in Backus-Naur Form
;
<sdat_file> ::= <session_line> [<data_order>] <sdat_header_line> <monitor_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <data_order> ::= "#data order:" [<whitespace>] ("default"|"time")|"device"|<hybrid_data_order>) <EOL>
    <hybrid_data_order> ::= "hybrid" <whitespace> [<hybrid_number_of_devices> [<hybrid_number_of_time_points>] ]
      <hybrid_number_of_devices> ::= <digit>+
      <hybrid_number_of_time_points> ::= <digit>+
  <sdat_header_line> ::= "#stress parameters:" [<whitespace>] "dev_index" <whitespace> <stress_parameter_list> <EOL>
    <stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <stress_parameter_data> ::= <time_device_data_block> | <hybrid_data_block>+
    <time_device_data_block> ::= <stress_parameter_data_line>+
    <hybrid_data_block> ::= ["#" [<whitespace>] <hybrid_data_order> <EOL>] <stress_parameter_data_line>+
      <stress_parameter_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
        <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
          <test_data> ::= <number>
;
; Notes on sdat Content
; ---------------------
; sdat has the same format as the mdat file, except for four important
; considerations:
;   1. sdat contains 1 less time point than mdat
;   2. sdat may contain only time zero data and still be valid
;   3. control devices would not be included in sdat
;   4. if the stimes file exists, sdat data will correspond to time
;       points in this stimes file.
;
; Consideration 1 stems from the fact that sdat contains stress parameter
; data, which by definition means they are measured during stress only.
; In most test systems stress parameters are measured after the time zero
; monitor data (so as not to cause pre-stress), i.e. at the beginning of 
; each stress/measure cycle.  Note that because the very first stress
; parameter reading is done at the very beginning of the first 
; stress/measure cycle, it is considered t=0 data and is labeled as such
; in the diagrams below.
;
; Consideration 2 stems from the fact that many test systems allow the
; choice of measuring stress parameters only once in the first 
; stress/measure cycle (in order to avoid extra stress due to measurement
; of stress parameters).
;
; Consideration 3 stems from the fact that control devices see no stress
; biases, so no stress parameter measurements are performed on them.
;
; Consideration 4 stems from the fact that some test systems measure (and
; log) stress parameters in a continuous or semi-continuous manner, and 
; it may not be easy to decipher which measurement points correspond to
; times in the mtimes file.  In those cases, simply reading the stimes and
; stress parameter measurement data from the original dataset is most
; efficient, and closer to the TSDF philosophy of matching the raw data as
; closely as possible.
; 
; sdat may use the same or different data orders as the mdat file in a 
; stress session. It is recommended that the mdat and sdat files use the
; same order.  The remaining sdat explanation is the same as found for
; the mdat file.
;
; <session_name> is the same session name as found in the sessioninfo file.
; <data_order> defines the "data order" used in the mdat file.  Data order
;   can be:
;       "time" (or "default")
;       "device"
;       "hybrid"
;   <data_order> is optional for the "time" (default) data order.  For the
;   hybrid data ordering, if with the same number of devices are stressed
;   for each site, then the <hybrid_number_of_devices> integer can be written
;   here.  In addition, if the same number of time points will be measured for
;   all devices, then the <hybrid_number_of_time_points> integer can also be
;   written.  If <hybrid_number_of_devices> is written on this line,
;   there is no need for embedded <hybrid_data_order> lines in each
;   <hybrid_data_block>.  Note that the optional <hybrid_number_of_time_points>
;   is redundant, as once the number of devices is known for each site,
;   the number of time points is specified in the mtimes file for each device.
; <sdat_header_line> conains <stress_parameter_list>, which is the list of
;   stress parameters that have data in the sdat file.  They are ordered
;   the same as the data columns.  In other words, the stress parameter
;   list contains the column names of the data in the sdat file.  The same
;   list will be optionally found in the sessioninfo file on the
;   "stress_parameters" row.
; <stress_parameter_data> is ordered not only by column, but also by device
; and monitor times.  There are several possible orderings.  This added
; complexity is to allow different types of test systems to output TSDF
; directly by simply appending to existing TSDF: no need to rewrite entire
; files.  This will become clear with the examples given below.
;
; For the hybrid data order with different number of devices in different
; sites (i.e. different <hybrid_data_block>), the <hybrid_data_order> is
; embedded in the <hybrid_data_block> for each site, and it must include
; the <hybrid_number_of_devices> entry.
;
; For directly plotting time-series curves for each device in a dataset,
; the "device" order is the easiest to parse, as data will be organized
; in device blocks, each block being a set of mtimes for a specific device.
;
; For directly plotting boxplots or distributons of sets of devices from
; a single monitor time point, the "time" order would be the easiest to parse.
;
; Stress parameters can be different for different devices in sdat.
; If this is the case, the <stress_parameter_list> will include all the
; stress parameters for all devices, and data padding (see the next
; paragraph) will be needed.
;
; Data points must sometimes be added to keep the data block the same
; size, or the number of columns the same.  Padded data is denoted by the
; value <padding_data>.  Testers could also output data with error
; information embedded in the values.  This data may be incorporated into
; the sdat file for later diagnostics etc, or use the default value 
; <bad_data> for bad data.
;
; Each data line (<monitor_data_line>) begins with the <dev_index> of the 
; device associated with that data row, then data corresponding each column
; defined in the <monitor_parameter_list>, with padding as needed (see above).
; The <dev_index> for each device is given in the devinfo file and is
; essentially the index into the devinfo table.
;
; ***********************
; Order by Time (Default)
; ***********************
; The default ordering is in blocks of stress/measure cycles, each block 
; containing data for a given stress/measure cycle for all devices, each
; device's data is in a separate row.  The order of devices, i.e. rows, 
; within a block is determined by the order of devices found in the 
; devinfo file.
;
; This format is most convenient for test systems that do a stress session
; on a single DUT or set of DUTs in parallel, for example a set of packaged
; parts, or a single touchdown on a wafer-level test system.  Note that
; all DUTs must have the same number of time points (time zero plus the 
; number of stress/measure cycles).  If they don't, padding data must be 
; added to devices with a smaller number of stress/measure cycles.  Padding
; data is given by the value 4e44.
;
; The order of the stress/measure cycle blocks is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L non-control devices and 
; M stress/measure cycles:
;      ------------------------------------------
;      |                                        |
;      |      Time=0, Devices 1 through L       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t1, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t2, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Time=tM-1, Devices 1 through L    |
;      |                                        |
;      ------------------------------------------
;
; Here's what the sdat file would look like in detail for L non-control
; devices, N stress parameters (aka sparams), and M stress/measure cycles:
; #session: <session_name>
; #data order: time
; #stress parameters: <sparam_name1> <sparam_name2> ... <sparam_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev3_t0_sparam1 data_dev3_t0_sparam2 ... data_dev3_t0_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev3_t1_sparam1 data_dev3_t1_sparam2 ... data_dev3_t1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
; data_dev3_tM-1_sparam1 data_dev3_tM-1_sparam2 ... data_dev3_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
;
; ***************
; Order by Device
; ***************
; Another way to accomodate DUTs with different numbers of stress/measure
; cycles is to order the data in blocks of devices, each block containing
; data for a given device for each stress/measure cycle.  The order of
; data blocks is given by the order of devices found in the devinfo file.
;
; This format is most convenient for a stress session on a single DUT only,
; but stepped across several devices, i.e stressing in series.  An example 
; of such a stress would be a fast WLR test on a single component over
; many sites over many wafers.
;
; The order of the stress/measure cycles is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L non-control devices and 
; M stress/measure cycles (although each device could actually have 
; different numbers of stress/measure cycles):
;      ------------------------------------------
;      |                                        |
;      |      Device 1, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 2, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 3, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Device L, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;
; Here's what the sdat file would look like in detail for L non-control
; devices, N stress parameters, and M stress/measure cycles:
; #session: <session_name>
; #data order: device
; #stress parameters: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev1_t2_sparam1 data_dev1_t2_sparam2 ... data_dev1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev2_t2_sparam1 data_dev2_t2_sparam2 ... data_dev2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
; data_devL_t3_sparam1 data_devL_t3_sparam2 ... data_devL_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
;
; ************
; Hybrid Order
; ************
; Of course, many WLR tests that step over many sites (and possibly
; many wafers) may also stress several devices in parallel during a 
; single touchdown.  Such a hybrid parallel/series type of stress session
; can be accomodated using the format that is a hybrid of the previous 
; two formats.
;
; Note that for the hybrid format, all devices within the same site must
; have the same number of of time points (M in this example: the t=0 plus
; M-1 stress parameter readings).  If devices have less, they need to be
; padded with 4e44 values to fill out the number of rows and columns.
; The number of times points could be different for different sites.
;
; Here's a block diagram of the ordering for S sites probed in series, 
; each site stressing L non-control devices in parallel for 
; M stress/measure cycles:
;
;  --------------------------------------------------
;  | Site 1 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices 1 through L       |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM-1, Devices 1 through L    |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;  --------------------------------------------------
;  | Site 2 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices L+1 through 2*L   |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |    Time=tM-1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;  --------------------------------------------------
;  | Site S stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=0, Devices (S-1)*L+1 through S*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t1, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t2, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=tM-1, Devices (S-1)*1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;
; Here's what the sdat file would look like in detail for S sites probed
; in series, each site stressing L non-control devices in parallel, 
; N stress parameters, and M stress/measure cycles (L below would 
; be replaced by an integer):
; #session: <session_name>
; #data order: hybrid L
; #stress parameters: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev1_t2_sparam1 data_dev1_t2_sparam2 ... data_dev1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev2_t2_sparam1 data_dev2_t2_sparam2 ... data_dev2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
; data_devL_t3_sparam1 data_devL_t3_sparam2 ... data_devL_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
; data_devL+1_t0_sparam1 data_devL+1_t0_sparam2 ... data_devL+1_t0_sparamN
; data_devL+1_t1_sparam1 data_devL+1_t1_sparam2 ... data_devL+1_t1_sparamN
; data_devL+1_t2_sparam1 data_devL+1_t2_sparam2 ... data_devL+1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL+1_tM-1_sparam1 data_devL+1_tM-1_sparam2 ... data_devL+1_tM-1_sparamN
; data_devL+2_t0_sparam1 data_devL+2_t0_sparam2 ... data_devL+2_t0_sparamN
; data_devL+2_t1_sparam1 data_devL+2_t1_sparam2 ... data_devL+2_t1_sparamN
; data_devL+2_t2_sparam1 data_devL+2_t2_sparam2 ... data_devL+2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL+2_tM-1_sparam1 data_devL+2_tM-1_sparam2 ... data_devL+2_tM-1_sparamN
; data_dev2*L_t0_sparam1 data_dev2*L_t0_sparam2 ... data_dev2*L_t0_sparamN
; data_dev2*L_t1_sparam1 data_dev2*L_t1_sparam2 ... data_dev2*L_t1_sparamN
; data_dev2*L_t3_sparam1 data_dev2*L_t3_sparam2 ... data_dev2*L_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_tM-1_sparam1 data_dev2*L_tM-1_sparam2 ... data_dev2*L_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+1_t0_sparam1 data_dev(S-1)*L+1_t0_sparam2 ... data_dev(S-1)*L+1_t0_sparamN
; data_dev(S-1)*L+1_t1_sparam1 data_dev(S-1)*L+1_t1_sparam2 ... data_dev(S-1)*L+1_t1_sparamN
; data_dev(S-1)*L+1_t2_sparam1 data_dev(S-1)*L+1_t2_sparam2 ... data_dev(S-1)*L+1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+1_tM-1_sparam1 data_dev(S-1)*L+1_tM-1_sparam2 ... data_dev(S-1)*L+1_tM-1_sparamN
; data_dev(S-1)*L+2_t0_sparam1 data_dev(S-1)*L+2_t0_sparam2 ... data_dev(S-1)*L+2_t0_sparamN
; data_dev(S-1)*L+2_t1_sparam1 data_dev(S-1)*L+2_t1_sparam2 ... data_dev(S-1)*L+2_t1_sparamN
; data_dev(S-1)*L+2_t2_sparam1 data_dev(S-1)*L+2_t2_sparam2 ... data_dev(S-1)*L+2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+2_tM-1_sparam1 data_dev(S-1)*L+2_tM-1_sparam2 ... data_dev(S-1)*L+2_tM-1_sparamN
; data_devS*L_t0_sparam1 data_devS*L_t0_sparamS ... data_devS*L_t0_sparamN
; data_devS*L_t1_sparam1 data_devS*L_t1_sparamS ... data_devS*L_t1_sparamN
; data_devS*L_t3_sparam1 data_devS*L_t3_sparamS ... data_devS*L_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_tM-1_sparam1 data_devS*L_tM-1_sparamS ... data_devS*L_tM-1_sparamN
;
; Note one more aspect of the hybrid data ordering. In many wafer level
; test programs, each site would contain multiple modules tested in
; sequence.  For example, each site testing might start off with a simple
; probecheck, which is a measure of the parasitic resistance in the probes
; and probe pads and would have nothing to do with the subsequent reliability
; testing of other modules/devices in the site.  This is not a issue for
; TSDF, as TSDF requires a single test_type in a dataset.  Test programs
; that have probechecks and/or multiple test_types create output that would
; by definition have to be converted to multiple TSDF stress sessions.  This
; could be done at the test system level, if the test shell supports creation
; of multiple data files from a run.  If not, the conversion program from
; the native test sysem format to TSDF would have to account for the
; multiple test_types in the original dataset.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; *********
; * ivdat *
; *********
;
; TSDF ivdat file syntax in Backus-Naur Form
;
<ivdat_file> ::= <session_line> <device_id_line> <ivdat>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <device_id_line> ::= "#IV Data for device " <dev_info> <EOL>
  <ivdat> ::= (<ivdat_block> [<EOL>])+
    <ivdat_block> ::= [<description_line>] <format> <iv_header_line> <iv_data> "#end" <EOL>
      <description_line> ::= "#" <text> <EOL>
      <format> ::= "#" [<whitespace>] "format=" [<whitespace>] ("short" | "long") <EOL>
      <iv_header_line> ::=  <header_line_short> | <header_line_long> <EOL>
        <header_line_short> ::= "#" [<whitespace>] <time_interval> <whitespace> <iv_label> <whitespace> <measured_param_list> "@" <sweep_def> <whitespace> [<step_def>] <bias_list> [<units_string>] [<sweep_rate>] <EOL>
        <header_line_long> ::= "#" [<whitespace>] <time_interval> <whitespace> <iv_label> <whitespace> <measured_param_list> [<bias_list>] [<units_string>] [<sweep_rate>] <EOL>
          <time_interval> ::= "t=" ("pre_stress" [<prestress_index>] | "post_stress" [<poststress_index>] | <digit>+)
            <prestress_index> ::= <digit>+
            <poststress_index> ::= <digit>+
          <iv_label> ::= "IV=" <alphanumeric>+
          <measured_param_list> ::= <measured_param> | (<measured_param> "," <measured_param_list>)
            <measured_param> ::= <alphanumeric>+
          <sweep_def> ::= <sweep_var_name> ["[" <units> "]"] "=" <sweep_values>
          <step_def> ::= <step_var_name> ["[" <units> "]"] "=" <sweep_values>
            <sweep_var_name> ::= <alphanumeric>+
            <step_var_name> ::= <alphanumeric>+
            <sweep_values> ::= "[" <number_list> "]"
          <bias_list> ::= <bias_def> | (<bias_def> <bias_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <number> <whitespace>
              <bias_name> ::= <alphanumeric>+
          <units_string> ::= "units=" <units_list>
            <units_list> ::= <units> | (<units> "," <units_list>)
          <sweep_rate> ::= "sweep_rate=" <number> [<whitespace>] <units>
      <iv_data> ::= <ivdata_line>+
        <ivdata_line> ::= <ivdata_pt>+ <EOL>
          <ivdata_pt> ::= <number> <whitespace>
;
; Notes on ivdat Content
; ----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <device_id_line> is informational. For example: "IV data for device 5"
; <ivdat> is split up into blocks, one IV curve per block
; <ivdat_block> is the IV curve, consisting of metadata followed by
;   the IV data.  The metadata consists of an optional <description_line>,
;   a required <format> line,  and a required header line <iv_header_line>.
; <iv_header_line> format (and IV data format) will depend on the <format> line
;   contents.  There are 2 possible formats, as described below.
; <description_line> (optional, but highly recommended), Examples:
;          "Isub vs Vg for Vd=1.8 to 2.8 V"
;          "Id vs Vg for Vd=0.05 V"
; <format> (one of these two):
;          "format=short"
;          "format=long"
; <iv_header_line> for format=short gives the following information:
;        <time_interval>: the time point (index found in mtimes file), or
;          pre_stress, or post_stress with or without index values.  It is NOT
;          the actual stress time.
;        <iv_label>: defines a label for the curve
;        <measured_param_list>: defines the measurement parameters
;        <sweep_def>: defines sweep parameters
;        <step_def>: defines step parameters
;        <bias_list>: defines other terminal biases
;        <units_string>: (optional) defines units of the measurement parameters
;        <sweep_rate>: (optional) defines the sweep rate of the IV sweep, e.g.
;          as V/s or MV/cm/s or I/s.  Units are are not optional, so the value
;          given will not be ambiguous.
;        Using the example "Isub vs Vg for Vd=1.8 to 2.8 V" IV for t=0, the
;        header line would be:
;          # t=0 iv=B Isub@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        Note that <time_interval> is 0,1,2,3..., i.e. not the stress time,
;        but the stress interval index, i.e. t=0 is time zero.
;        Also valid are the following time intervals:
;           t=pre_stress -- for IV curves taken before the start of stress,
;             even before any t=0 IV curves.
;           t=pre_stress2 -- for IV curves taken before the start of stress,
;             but after t=pre_stress IV curves that are known to cause
;             degradation.
;           t=post_stress -- for IV curves taken after the stress session
;             has finished.
;        The <iv_label> can be any label the user wants.  There is an
;        established convention for iv labels for some common IV curves:
;           MOSFET linear Id-Vg: iv=L
;           MOSFET saturation Id-Vg: iv=S
;           MOSFET full Id-Vd family of curves: iv=F
;           MOSFET Isub-Vg family of curves: iv=B
;           MOSFET Igate-Vg family of curves: iv=G
;           Any MOSFET curve performed with source and drain reversed: add
;             suffix 'R' to the label.  Examples: 'LR', 'SR', 'FR', 'BR'
;           Capacitor ramp IV data: iv=Vramp or iv=Jramp depending on type
;             of ramp
;           Bipolar Gummel plot: iv=Gummel
;           Bipolar full Ic-Vce family of curves: iv=F
;           ?* Predefine other BJT IV's here *?
;        The <measured_param_list> is a comma separated list of names of
;        the measured parameter or parameters (a list of <measured_param>'s).
;        This is allowed because many test systems can measure several
;        terminal voltages or currents simultaneously in a single sweep.
;        If the example here had been 
;             "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        the <iv_header_line> would be:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        Note that if <measured_param> starts with 'I' or 'i', the units
;        are assumed to be 'A' (amps), and if it starts with 'V' or 'v',
;        the units are assumed to be 'V' (volts).  If these are not the
;        correct units, or <measured_param> starts with a different letter,
;        the units can be defined in the optional <units_string> as the last 
;        entry of the <iv_header_line>.  For example, if Isub is in 'mA' 
;        (milliamps), the <iv_header_line> would be:
;          # t=0 iv=B Isub@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=mA
;        or for Isub and Id milliamps:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=mA,mA
;        Note that to remove ambiguity, if any <measured_param> in 
;        <measured_param_list> has a specified units, all <measured_param>'s
;        must have their units specified.  For Isub in amps and Id in mA:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=A,mA
;
;        The primary sweep, <sweep_def>, is defined next, as a list of 
;        real numbers.  The values don't have to be monotonically increasing
;        or decreasing, but they normally do, as they must correspond to 
;        each sweep value used in the IV measurement.  The <sweep_def> format
;        is equivalent to Matlab's convention for defining lists (vectors
;        actually in Matlab's parlance): a list of whitespace separated
;        elements, each element being a real number or integer, or the 
;        Matlab shorthand notation element=start:step:stop.  The latter
;        notation is for defining the start, step, and stop values of the 
;        sweep.  The list is monotonically increasing if
;        the <start> value is less than the <stop> value and the <step> value
;        is positive.  The list is monotonically decreasing if the <start>
;        value is greater than the <stop> value and the <step> value is
;        negative.
;        Most IV sweeps will be a constant step, so an IV sweep from 0 to 
;        5 V with a 0.05 V step could be written compactly as: [0:0.05:5].  
;        IV curves with different step values in different parts of the sweep
;        can be accommodated with a list using multiple start:step:stop 
;        elements.  For example, an IV that steps 0.05 V between 0 and 2,
;        then 0.02 V steps between 2 and 3.3 V would be written as:
;        [0:0.05:2 2.02:0.02:3.3].
;        The sweep parameters have the same convention for automatically
;        setting units as the measured parameters.  If the <sweep_var_name>
;        starts with 'I' or 'i', units are set to 'A' (amps), and if it
;        starts with 'V' or 'v', units are set to 'V' (volts).  If these
;        are not the correct units, or the <sweep_var_name> starts with a
;        different letter, the units can be defined in the adjacent [<units>]
;        string.  For example, Vg in mV:
;          # t=0 iv=B Isub@Vg[mV]=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;         
;        The secondary sweep, which is called the step here, <step_def>, is
;        optional as not all IV curves use a stepped parameter.  <step_def>
;        has the same format as <sweep_def>.
;
;        The remaining terminal voltages are defined in <bias_list> and are
;        assumed to be DC values.  Electrical ground is 0 V as usual.
;        <bias_name> has the same convention for automatically
;        setting units as the sweep and step parameters.  If the <bias_name>
;        starts with 'I' or 'i', units are set to 'A' (amps), and if it
;        starts with 'V' or 'v', units are set to 'V' (volts).  If these
;        are not the correct units, or the <bias_name> starts with a
;        different letter, the units can be defined in the adjacent [<units>]
;        string.  For example, Vd in mV for a linear Id-Vg sweep:
;          # t=0 iv=L Id@Vg=[0:0.02:2.8] Vd[mV]=100 Vs=0 Vb=0
;
;        Finally, comes the data!  There will be as many <iv_data_line>'s
;        (i.e. rows) as there are sweep values defined in <sweep_def>.
;        There will be as many <iv_data_pt>'s (i.e. columns) as the
;        number of step values times the number of measured parameters.
;        For our example of "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        with the following <iv_header_line>:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        the <iv_data> would look like this, using Isub(Vg,Vd) and Id(Vg,Vd):
;      
; Isub(0,1.8) Isub(0,2.3) Isub(0,2.8) Id(0,1.8) Id(0,2.3) Id(0,2.8)
; Isub(.02,1.8) Isub(.02,2.3) Isub(.02,2.8) Id(.02,1.8) Id(.02,2.3) Id(.02,2.8)
; Isub(.04,1.8) Isub(.04,2.3) Isub(.04,2.8) Id(.04,1.8) Id(.04,2.3) Id(.04,2.8)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Isub(2.8,1.8) Isub(2.8,2.3) Isub(2.8,2.8) Id(2.8,1.8) Id(2.8,2.3) Id(2.8,2.8)
;
; <iv_header_line> for format=long gives the following information:
;        <time_interval>: the time point (see above)
;        <iv_label>: defines a label for the curve (see above)
;        <measured_param_list>: defines the measurement parameters (see above)
;           format=long, there is no sweep parameter definition.
;        <bias_list>: defines other terminal biases (see above)
;        <units_string>: (optional) defines units of the measurement parameters
;          (see above).
;        The <sweep_def> and <step_def> entries are not used.
;        Using the example "Isub vs Vg for Vd=1.8 to 2.8 V" IV for t=0, the
;        header line would be:
;          # t=0 iv=B Vg,Vd,Isub Vs=0 Vb=0
;        The <measured_param_list> is a comma separated list of names of
;        the measured parameter or parameters (a list of <measured_param>'s).
;        This is allowed because many test systems can measure several
;        terminal voltages or currents simultaneously in a single sweep.
;        If the example here had been 
;             "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        the <iv_header_line> would be:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0
;        The same convention as used in the format=short format for
;        specifying units applies.
;          # t=0 iv=B Vg,Vd,Isub Vs=0 Vb=0 units=V,V,mA
;        or for Isub and Id milliamps:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0 units=V,V,mA,mA
;        In the above examples, to remove ambiguity, all <measured_param>'s
;        had their units specified.  For Isub in amps and Id in mA, and Vg
;        in mV:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0 units=mV,V,A,mA
;
;        Terminal voltages that are not explicitly written in the IV data
;        are defined in <bias_list> and are assumed to be DC values.
;        Electrical ground is 0 V as usual.
;        <bias_name> has the same convention for automatically
;        setting units as already discussed.
;          # t=0 iv=L Vg,Id Vd[mV]=100 Vs=0 Vb=0
;
;        Finally, comes the data!  There will be as many <iv_data_line>'s
;        (i.e. rows) as there are sweep values defined in <sweep_def>.
;        There will be as many <iv_data_pt>'s (i.e. columns) as the
;        number of step values times the number of measured parameters.
;        For our example of "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        with the following <iv_header_line>:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0
;        the <iv_data> would look like this, assuming N Vg steps and M Vd steps:
;      
; Vg(1),Vd(1),Isub(1,1) Id(1,1)
; Vg(2),Vd(1),Isub(2,1) Id(2,1)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(1),Isub(N,1) Id(N,1)
; Vg(1),Vd(2),Isub(1,2) Id(1,2)
; Vg(2),Vd(2),Isub(2,2) Id(2,2)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(2),Isub(N,2) Id(N,2)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(M),Isub(N,M) Id(N,M)
;
; Important note: for every Vd step, the number of Vg steps could be different.
;  It is up to the analysis program to detect this in order to plot any 
;  family of curves correctly.  This behavior is not ideal, but is needed
;  to accomodate the IV data output of certain commerically available testers
;  (Aetrium 1164 testers).
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * predef *
; **********
; 
; TSDF predef file syntax in Backus-Naur Form
; 
<predef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= (<mdef_block> [<EOL>]) | (<mdef_block> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" <bias_def_list> [<units_string>] <EOL>
          <parameter_name> ::= <alphanumeric>+
          <bias_def_list> ::= <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
              <bias_name> ::= <alphanumeric>+
              <bias_value> ::= <number>
          <units_string> ::= "units=" <units>
;
; Notes on predef Content
; -----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; The predef file has the exact same format as the mdef file.  It is used in 
;   situations where a stress session includes a set of pre-stress parameter
;   measurements that can be different than the monitor parameters found
;   in the mdef and mdat files.  See the mdef section for more notes on
;   this parameter definition file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; **********
; * predat *
; **********
;
; TSDF predat file syntax in Backus-Naur Form
;
<predat_file> ::= <session_line> <predat_header_line> <pre_stress_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <predat_header_line> ::= "#pre-stress:" [<whitespace>] "dev_index" <whitespace> <pre_stress_parameter_list> <EOL>
    <pre_stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <pre_stress_data> ::= <pre_stress_data_line>+
    <pre_stress_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
      <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
;
; Notes on predat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <predat_file> has the same format as the mdat file, except since it is
;    data for a single time point (pre-stress), there is no variable data
;    order.  All data is presented in rows starting with the first device
;    and going through to the last device, in order the devices appear in
;    the devinfo file.
; Here's a block diagram of the ordering for L devices:
;      ------------------------------------------
;      |                                        |
;      |      Time=pre, Devices 1 through L     |
;      |                                        |
;      ------------------------------------------
;
; Here's what the predat file would look like in detail for L devices, and
; N pre-stress parameters:
; #session: <session_name>
; #pre-stress: <preparam_name1> <preparam_name2> ... <preparam_nameN>
; data_dev1_preparam1 data_dev1_preparam2 ... data_dev1_preparamN
; data_dev2_preparam1 data_dev2_preparam2 ... data_dev2_preparamN
; data_dev3_preparam1 data_dev3_preparam2 ... data_dev3_preparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_preparam1 data_devL_preparam2 ... data_devL_preparamN
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; ***********
; * postdef *
; ***********
; 
; TSDF postdef file syntax in Backus-Naur Form
; 
<postdef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= (<mdef_block> [<EOL>]) | (<mdef_block> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" <bias_def_list> [<units_string>] <EOL>
          <parameter_name> ::= <alphanumeric>+
          <bias_def_list> ::= <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
              <bias_name> ::= <alphanumeric>+
              <bias_value> ::= <number>
          <units_string> ::= "units=" <units>
;
; Notes on postdef Content
; ------------------------
; <session_name> is the same session name as found in the sessioninfo file.
; The postdef file has the exact same format as the mdef file.  It is used in 
;   situations where a stress session includes a set of post-stress parameter
;   measurements that can be different than the monitor parameters found
;   in the mdef and mdat files.  See the mdef section for more notes on
;   this parameter definition file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; **********
; * postdat *
; **********
;
; TSDF postdat file syntax in Backus-Naur Form
;
<postdat_file> ::= <session_line> <postdat_header_line> <post_stress_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <postdat_header_line> ::= "#post-stress:" [<whitespace>] "dev_index" <whitespace> <post_stress_parameter_list> <EOL>
    <post_stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <post_stress_data> ::= <post_stress_data_line>+
    <post_stress_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
      <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
;
; Notes on postdat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <postdat_file> has the same format as the mdat file, except since it is
;    data for a single time point (post-stress), there is no variable data
;    order.  All data is presented in rows starting with the first device
;    and going through to the last device, in order the devices appear in
;    the devinfo file.
; Here's a block diagram of the ordering for L devices:
;      ------------------------------------------
;      |                                        |
;      |      Time=post, Devices 1 through L    |
;      |                                        |
;      ------------------------------------------
;
; Here's what the postdat file would look like in detail for L devices, and
; N post-stress parameters:
; #session: <session_name>
; #post-stress: <postparam_name1> <postparam_name2> ... <postparam_nameN>
; data_dev1_postparam1 data_dev1_postparam2 ... data_dev1_postparamN
; data_dev2_postparam1 data_dev2_postparam2 ... data_dev2_postparamN
; data_dev3_postparam1 data_dev3_postparam2 ... data_dev3_postparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_postparam1 data_devL_postparam2 ... data_devL_postparamN
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ************
; * miscinfo *
; ************
;
; TSDF miscinfo file syntax in Backus-Naur Form
;
<miscinfo_file> ::= <session_line> <misc_fields>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <misc_fields> ::= (<misc_field_row> | <misc_field_row> <EOL> <misc_fields>)
    <misc_field_row ::= <misc_field_name> ":" [<whitespace>] <misc_field_value>
    <misc_field_name> ::= <alphanumeric>+
    <misc_field_value> ::= <text>
;
; Notes on miscinfo Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <miscinfo_file> contains rows of (field, value) pairs.  This metadata is
;    meant to be miscellaneous, meaning that the fields are not specifically
;    defined in TSDF, but could be unique to a lab or company.
;
;    For example, a lab or company may track reliability test requests via some
;    request workflow system.  The request naming convention will be unique
;    to that workflow system.  The lab or company would want the request 
;    information embedded in the TSDF session, but it would not be used if
;    the session files are shared with another lab or company. One can imagine
;    other useful information that would not translate across labs or 
;    companies, like test program information, detailed test system information,
;    or information on test structure documentation relevant to the devices
;    specified in the devinfo file.  A company or lab could employ some way
;    to extract charges for work performed, so a charge account number could
;    be used.  Again, such a field would only be relevant within a lab or
;    company, so it is put in the <miscinfo_file>.
;
;    Some possible miscellaneous fields are:
;      <request_number> - a job tracking number
;      <job_number> - a job tracking number, equivalent to <request_number>
;      <account> - financial accounting number for invoicing or tracking
;        payment of the service of reliability testing
;      <entity> - name of company or educational institution
;      <organization> - name of organization within <entity>
;      <lab> - name of lab within <entity> or <organizatin>
;      <contact_name> - name of person responsible for dataset
;      <engineer> - name of person responsible for dataset, equivalent to
;        <contact_name>
;      <person_responsible>> - name of person responsible for dataset, equivalent to
;        <contact_name>
;      <test_program> - name of test program used for stress testing
;      <test_shell> - name of test program environment or framework, may include
;        revision number of environment
;      <raw_data_format> - type of data output from stress test system
;      <sample_rate> - for TDDB or HTRB data with realtime output of Istress,
;        but only saving Istress to a log file at a certain sampling rate
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; ********
; * mdef *
; ********
; 
; TSDF mdef file syntax in Backus-Naur Form
; 
<mdef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= (<mdef_block> [<EOL>]) | (<mdef_block> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" [<whitespace>] <parameter_def_list> [<whitespace> <units_string>] [<whitespace> <parameter_desc>] <EOL>
          <parameter_name> ::= <alphanumeric>+
          <parameter_def_list> ::= <parameter_def> | <parameter_def> <whitespace> <parameter_def_list>
            <parameter_def> ::= "bias="<bias_def_list> | "equ="<parameter_equ> | "cmp="<parameter_cmp>
              <bias_def_list> ::=  <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
                <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
                  <bias_name> ::= <alphanumeric>+
                  <bias_value> ::= <number>
              <parameter_equ> ::=  <expr> | <whitespace> <expr>
                    <factor> ::= <variable> | <iv_reference>
                      <variable> ::= "<" <parameter_name> ">"
                      <iv_reference> ::= "'" <iv_label> "'"
                         <iv_label> ::= "IV=" <alphanumeric>+
              <parameter_cmp> ::= <bias_name> "@" <bias_name> <cmp_op> <expr>
                <cmp_op> ::= "==" | "<" | "<=" | ">" | ">=" | "!="
          <parameter_desc> ::= """ <text> """
          <units_string> ::= "units=" <units>
;
; Notes on mdef Content
; ---------------------
;   mdef has had a major upgrade in Rev 0.7, based on inputs from Keithley
;   back in 2013, and only now addressed.  Prior to Rev 0.7, mdef parameter
;   definitions consisted of bias values only, fine for spot measurements,
;   but not useful for more complex parameters such as extrapolated Vt (Vtx),
;   or transconductance (Gm), and also not useful for parameters based on
;   some threshold, like time to breakdown (Tbd) in TDDB defined by the
;   current through the capacitor test structure reaching a certain value.  
;   Support for these new types of parameter definitions required a more
;   complicated syntax, which is outlined below.
; <session_name> is the same session name as found in the sessioninfo file.
; <mdefs> is divided into blocks (<mdef_block>) of parameter definitions, each 
;   block containing parameter definitions for a set of devices with 
;   those monitor parameters.  If all devices have the same mdefs, there is
;   only one mdef block in the file, and the <device_line> line is optional.
;   If every device has a different set of parameter definitions, there will
;   be as many mdef blocks as there are devices.  Each block will have a
;   <device_line> line at its start to denote the device number that 
;   corresponds to the mdefs in that block.  In stress sessions where one
;   or more subsets of devices have the same mdefs, there will be mdef blocks
;   for each subset.
; <device_line> lists the device numbers for the mdef block.
; <mdef_line> consists of the <parameter_name> followed by the parameter 
;   definition 
; <parameter_def>, parameter definition can take two forms:
;       1. bias definitions
;       2. optional bias definitions plus a description, such as an equation
;              or similar
;   Bias definitions have the format <name>=<value> or 
;   <name>[<units>]=<value> if the user wants to specify the units.  Units
;   are sometimes optional because for <name> starting with "V" or "v", the
;   units are assumed to be Volts, and for <name> starting with "I" or  "i",
;   the units are assumed to be Amperes.  The same holds true for
;   <parameter_name>:
;   starting with "V" or "v" implies units of volts, and starting with
;   "I" or "i" implies units of amperes.  The optional <units_string>
;   definition specifies the parameter units if needed.
;
;   Since parameters can be calculated from other parameters or extracted
;   from IV curves, or even defined by a current level or change of
;   slope in a curve (example: Vbd of a Vramp test or TDDB), another way
;   to specify parameters is needed.  This is the role of the parameter
;   definition description (<parameter_def_desc>).  This description does
;   not try to ensure an equation is written correctly, so it can be
;   treated just like any text.  There are several conventions that should
;   be followed for consistency over mdef files from any source.  
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * mtimes *
; **********
; 
; TSDF mtimes file syntax in Backus-Naur Form
; 
<mtimes_file> ::= <session_line> [<time_units>] <mtimes>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <time_units> ::= "#units: sec" <EOL>
  <mtimes> ::= (<mtimes_block> [<EOL>]) | (<mtimes_block> <mtimes>)
    <mtimes_block> ::= [<device_line>] <device_mtimes>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mtimes> ::= <mtimes_line> | (<mtimes_line> <device_mtimes>)
        <mtimes_line> ::= [<whitespace>] <time_index> <whitespace> <mtimes_value> <EOL>
          <time_index> ::= <digit>+
          <mtimes_value> ::= <pos_number>
;
; Notes on mtimes Content
; -----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <time_units> is informational, as TSDF requires all time data to be in
;   units of seconds.
; <mtimes> is divided into blocks (<mtimes_block>) of mtime values, each 
;   block containing mtimes values for a set of devices with those mtimes.
;   If all devices have the same mtimes, there is only one mtimes block in 
;   the file, and the <device_line> line is optional.  If every device has a
;   different set of mtimes, there will be as many mtimes blocks as there
;   are devices.  Each block will have a <device_line> line at its start to
;   denote the device number that corresponds to the mtimes in that block.
;   In stress sessions where one or more subsets of devices have the same 
;   mtimes, there will be mtimes blocks for each subset.
; <device_line> lists the device numbers for the mtimes block.
; <mtimes_line> consists of two numbers: an index number (which starts at 0
;   for time=0), and the cumulative stress time at the end of that stress
;   interval, in seconds.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * stimes *
; **********
; 
; TSDF stimes file syntax in Backus-Naur Form
; 
<stimes_file> ::= <session_line> [<time_units>] <stimes>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <time_units> ::= "#units: sec" <EOL>
  <stimes> ::= (<stimes_block> [<EOL>]) | (<stimes_block> <stimes>)
    <stimes_block> ::= [<device_line>] <device_stimes>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_stimes> ::= <stimes_line> | (<stimes_line> <device_stimes>)
        <stimes_line> ::= [<whitespace>] <time_index> <whitespace> <stimes_value> <EOL>
          <time_index> ::= <digit>+
          <stimes_value> ::= <pos_number>
;
; Notes on stimes Content
; -----------------------
; stimes is an optional file that is useful in situations where the test
;   program monitors stress parameters at times different than the times
;   listed in the mtimes file.  An example would be if the stress parameters
;   are monitored semi-continuously.
; If the stimes file exists, the stress paraemters in the sdat file will
;   correspond to times in the stimes file.  If the stimes files does not
;   exist, the stres parameters in the sdat file will correspond to times in
;   the mtimes file.
; <session_name> is the same session name as found in the sessioninfo file.
; <time_units> is informational, as TSDF requires all time data to be in
;   units of seconds.
; <stimes> is divided into blocks (<stimes_block>) of stime values, each 
;   block containing stimes values for a set of devices with those stimes.
;   If all devices have the same stimes, there is only one stimes block in 
;   the file, and the <device_line> line is optional.  If every device has a
;   different set of stimes, there will be as many stimes blocks as there
;   are devices.  Each block will have a <device_line> line at its start to
;   denote the device number that corresponds to the stimes in that block.
;   In stress sessions where one or more subsets of devices have the same 
;   stimes, there will be stimes blocks for each subset.
; <device_line> lists the device numbers for the stimes block.
; <stimes_line> consists of two numbers: an index number (which starts at 0
;   for time=0), and the cumulative stress time at the end of that stress
;   interval, in seconds.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ********
; * mdat *
; ********
;
; TSDF mdat file syntax in Backus-Naur Form
;
<mdat_file> ::= <session_line> [<data_order>] <mdat_header_line> <monitor_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <data_order> ::= "#data order:" [<whitespace>] ("default"|"time")|"device"|<hybrid_data_order>) <EOL>
    <hybrid_data_order> ::= "hybrid" <whitespace> [<hybrid_number_of_devices> [<hybrid_number_of_time_points>] ]
      <hybrid_number_of_devices> ::= <digit>+
      <hybrid_number_of_time_points> ::= <digit>+
  <mdat_header_line> ::= "#monitors:" [<whitespace>] "dev_index" <whitespace> <monitor_parameter_list> <EOL>
    <monitor_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <monitor_data> ::= <time_device_data_block> | <hybrid_data_block>+
    <time_device_data_block> ::= <monitor_data_line>+
    <hybrid_data_block> ::= ["#" [<whitespace>] <hybrid_data_order> <EOL>] <monitor_data_line>+
      <monitor_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
        <dev_index> ::= <digit>+
        <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
          <test_data> ::= <number>
;
; Notes on mdat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <data_order> defines the "data order" used in the mdat file.  Data order
;   can be:
;       "time" (or "default")
;       "device"
;       "hybrid"
;   <data_order> is optional for the "time" (default) data order.  For the
;   hybrid data ordering, if the same number of devices are stressed
;   for each site, then the <hybrid_number_of_devices> integer can be written
;   here.  In addition, if the same number of time points will be measured for
;   all devices, then the <hybrid_number_of_time_points> integer can also be
;   written.  If <hybrid_number_of_devices> is written on this line,
;   there is no need for embedded <hybrid_data_order> lines in each
;   <hybrid_data_block>.  Note that the optional <hybrid_number_of_time_points>
;   is redundant, as once the number of devices is known for each site,
;   the number of time points is specified in the mtimes file for each device.
; <mdat_header_line> conains <monitor_parameter_list>, which is the list of
;   monitor parameters that have data in the mdat file.  They are ordered
;   the same as the data columns.  In other words, the monitor parameter
;   list contains the column names of the data in the mdat file.  The same
;   list will be optionally found in the sessioninfo file on the
;   "monitor_parameters" row.
; <monitor_data> is ordered not only by column, but also by device and
; monitor times.  There are several possible orderings.  This added
; complexity is to allow different types of test systems to output TSDF
; directly by simply appending to existing TSDF: no need to rewrite entire
; files.  This will become clear with the examples given below.
;
; For directly plotting degradation curves for each device in a dataset,
; the "device" order is the easiest to parse, as data will be organized
; in device blocks, each block being a set of mtimes for a specific device.
;
; For directly plotting boxplots or distributons of sets of devices from
; a single monitor time point, the "time" order would be the easiest to parse.
;
; For the hybrid data order with different number of devices in different
; sites (i.e. different <hybrid_data_block>), the <hybrid_data_order> is
; embedded in the <hybrid_data_block> for each site, and it must include
; the <hybrid_number_of_devices> entry.
;
; Monitor data parameters can be different for different devices in mdat.
; If this is the case, the <monitor_parameter_list> will include all the
; monitor parameters for all devices, and data padding (see the next
; paragraph) will be needed.
;
; Data points must sometimes be added to keep the data block the same
; size, or the number of columns the same.  Padded data is denoted by the
; value <padding_data>.  Testers could also output data with error
; information embedded in the values.  This data may be incorporated into
; the mdat file for later diagnostics etc, or use the default value 
; <bad_data> for bad data.
;
; Each data line (<monitor_data_line>) begins with the <dev_index> of the 
; device associated with that data row, then data corresponding each column
; defined in the <monitor_parameter_list>, with padding as needed (see above).
; The <dev_index> for each device is given in the devinfo file and is
; essentially the index into the devinfo table.
;
; ***********************
; Order by Time (Default)
; ***********************
; The default ordering is in blocks of stress/measure cycles, each block 
; containing data for a given stress/measure cycle for all devices, each
; device's data is in a separate row.  The order of devices, i.e. rows, 
; within a block is determined by the order of devices found in the 
; devinfo file.
;
; This format is most convenient for test systems that do a stress session
; on a single DUT or set of DUTs in parallel, for example a set of packaged
; parts, or a single touchdown on a wafer-level test system.  Note that
; all DUTs must have the same number of time points (time zero plus the 
; number of stress/measure cycles).  If they don't, padding data must be 
; added to devices with a smaller number of stress/measure cycles.  Padding
; data is given by the value <padding_data>.
;
; The order of the stress/measure cycle blocks is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L devices and M stress/measure
; cycles:
;      ------------------------------------------
;      |                                        |
;      |      Time=0, Devices 1 through L       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t1, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t2, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Time=tM, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;
; Here's what the mdat file would look like in detail for L devices, 
; N monitor parameters (aka mparams), and M stress/measure cycles:
; #session: <session_name>
; #data order: time
; #monitors: <mparam_name1> <mparam_name2> ... <mparam_nameN>
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev3_t0_mparam1 data_dev3_t0_mparam2 ... data_dev3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev3_t1_mparam1 data_dev3_t1_mparam2 ... data_dev3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
; data_dev3_tM_mparam1 data_dev3_tM_mparam2 ... data_dev3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
;
; ***************
; Order by Device
; ***************
; Another way to accomodate DUTs with different numbers of stress/measure
; cycles is to order the data in blocks of devices, each block containing
; data for a given device for each stress/measure cycle.  The order of
; data blocks is given by the order of devices found in the devinfo file.
;
; This format is most convenient for a stress session on a single DUT only,
; but stepped across several devices, i.e stressing in series.  An example 
; of such a stress would be a fast WLR test on a single component over
; many sites over many wafers.
;
; The order of the stress/measure cycles is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L devices and M stress/measure
; cycles (although each device could actually have different numbers of
; stress/measure cycles; such information would be found in the mtimes
; file):
;      ------------------------------------------
;      |                                        |
;      |      Device 1, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 2, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 3, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Device L, Times 0 through M       |
;      |                                        |
;      ------------------------------------------
;
; Here's what the mdat file would look like in detail for L devices, 
; N monitor parameters, and M stress/measure cycles:
; #session: <session_name>
; #data order: device
; #monitors: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev1_t2_mparam1 data_dev1_t2_mparam2 ... data_dev1_t2_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev2_t2_mparam1 data_dev2_t2_mparam2 ... data_dev2_t2_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
; data_devL_t3_mparam1 data_devL_t3_mparam2 ... data_devL_t3_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
;
; ************
; Hybrid Order
; ************
; Of course, many WLR tests that step over many sites (and possibly
; many wafers) may also stress several devices in parallel during a 
; single touchdown.  Such a hybrid parallel/series type of stress session
; can be accomodated using the format that is a hybrid of the previous 
; two formats.
;
; Note that for the hybrid format, all devices within the same site must
; have the same number of time points (M+1 in this example).  If devices
; have less, they need to be padded with <padding_data> to fill out the
; number of rows and columns.  The number of time points could be different
; for different sites.  The number of time points is found in the mtimes
; file.
;
; Here's a block diagram of the ordering for S sites probed in series, 
; each site stressing L devices in parallel for M stress/measure cycles:
;
;  --------------------------------------------------
;  | Site 1 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices 1 through L       |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;  --------------------------------------------------
;  | Site 2 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices L+1 through 2*L   |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;  --------------------------------------------------
;  | Site S stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=0, Devices (S-1)*L+1 through S*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t1, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t2, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=tM, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;
; Here's what the mdat file would look like in detail for S sites probed
; in series, each site stressing L devices in parallel, N monitor parameters,
; and M stress/measure cycles (L below would be replaced by an integer).
; Note that because L is the same for all sites, the data order line
; (the one that starts with "#data order:") could contain the L value,
; and the embedded "# hybrid L" lines could be removed.  The sdat file
; example for the hybrid data order shows this alternative format.  Here
; is the example mdat file:
; #session: <session_name>
; #data order: hybrid
; #monitors: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; # hybrid L
; data_dev1_t0_mparam1 data_dev1_t0_mparam2 ... data_dev1_t0_mparamN
; data_dev2_t0_mparam1 data_dev2_t0_mparam2 ... data_dev2_t0_mparamN
; data_dev3_t0_mparam1 data_dev3_t0_mparam2 ... data_dev3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_mparam1 data_devL_t0_mparam2 ... data_devL_t0_mparamN
; data_dev1_t1_mparam1 data_dev1_t1_mparam2 ... data_dev1_t1_mparamN
; data_dev2_t1_mparam1 data_dev2_t1_mparam2 ... data_dev2_t1_mparamN
; data_dev3_t1_mparam1 data_dev3_t1_mparam2 ... data_dev3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_mparam1 data_devL_t1_mparam2 ... data_devL_t1_mparamN
; data_dev1_tM_mparam1 data_dev1_tM_mparam2 ... data_dev1_tM_mparamN
; data_dev2_tM_mparam1 data_dev2_tM_mparam2 ... data_dev2_tM_mparamN
; data_dev3_tM_mparam1 data_dev3_tM_mparam2 ... data_dev3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM_mparam1 data_devL_tM_mparam2 ... data_devL_tM_mparamN
; # hybrid L
; data_devL+1_t0_mparam1 data_devL+1_t0_mparam2 ... data_devL+1_t0_mparamN
; data_devL+2_t0_mparam1 data_devL+2_t0_mparam2 ... data_devL+2_t0_mparamN
; data_devL+3_t0_mparam1 data_devL+3_t0_mparam2 ... data_devL+1_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_t0_mparam1 data_dev2*L_t0_mparam2 ... data_dev2*L_t0_mparamN
; data_devL+1_t1_mparam1 data_devL+1_t1_mparam2 ... data_devL+1_t1_mparamN
; data_devL+2_t1_mparam1 data_devL+2_t1_mparam2 ... data_devL+2_t1_mparamN
; data_devL+3_t1_mparam1 data_devL+3_t1_mparam2 ... data_devL+3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_t1_mparam1 data_dev2*L_t1_mparam2 ... data_dev2*L_t1_mparamN
; data_devL+1_tM_mparam1 data_devL+1_tM_mparam2 ... data_devL+1_tM_mparamN
; data_devL+2_tM_mparam1 data_devL+2_tM_mparam2 ... data_devL+2_tM_mparamN
; data_devL+3_tM_mparam1 data_devL+3_tM_mparam2 ... data_devL+3_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_tM_mparam1 data_dev2*L_tM_mparam2 ... data_dev2*L_tM_mparamN
; # hybrid L
; data_dev2*L+1_t0_mparam1 data_dev2*L+1_t0_mparam2 ... data_dev2*L+1_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev3*L_tM_mparam1 data_dev3*L_tM_mparam2 ... data_dev3*L_tM_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; # hybrid L
; data_dev(S-1)*L+1_t0_mparam1 data_dev(S-1)*L+1_t0_mparam2 ... data_dev(S-1)*L+1_t0_mparamN
; data_dev(S-1)*L+2_t0_mparam1 data_dev(S-1)*L+2_t0_mparam2 ... data_dev(S-1)*L+2_t0_mparamN
; data_dev(S-1)*L+3_t0_mparam1 data_dev(S-1)*L+3_t0_mparam2 ... data_dev(S-1)*L+3_t0_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_t0_mparam1 data_devS*L_t0_mparam2 ... data_devS*L_t0_mparamN
; data_dev(S-1)*L+1_t1_mparam1 data_dev(S-1)*L+1_t1_mparam2 ... data_dev(S-1)*L+1_t1_mparamN
; data_dev(S-1)*L+2_t1_mparam1 data_dev(S-1)*L+2_t1_mparam2 ... data_dev(S-1)*L+2_t1_mparamN
; data_dev(S-1)*L+3_t1_mparam1 data_dev(S-1)*L+3_t1_mparam2 ... data_dev(S-1)*L+3_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_t1_mparam1 data_devS*L_t1_mparam2 ... data_devS*L_t1_mparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_tM_mparam1 data_devS*L_tM_mparamS ... data_devS*L_tM_mparamN
;
; Note one more aspect of the hybrid data ordering. In many wafer level
; test programs, each site would contain multiple modules tested in
; sequence.  For example, each site testing might start off with a simple
; probecheck, which is a measure of the parasitic resistance in the probes
; and probe pads and would have nothing to do with the subsequent reliability
; testing of other modules/devices in the site.  This is not a issue for
; TSDF, as TSDF requires a single test_type in a dataset.  Test programs
; that have probechecks and/or multiple test_types create output that would
; by definition have to be converted to multiple TSDF stress sessions.  This
; could be done at the test system level, if the test shell supports creation
; of multiple data files from a run.  If not, the conversion program from
; the native test sysem format to TSDF would have to account for the
; multiple test_types in the original dataset.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ********
; * sdat *
; ********
;
; TSDF sdat file syntax in Backus-Naur Form
;
<sdat_file> ::= <session_line> [<data_order>] <sdat_header_line> <monitor_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <data_order> ::= "#data order:" [<whitespace>] ("default"|"time")|"device"|<hybrid_data_order>) <EOL>
    <hybrid_data_order> ::= "hybrid" <whitespace> [<hybrid_number_of_devices> [<hybrid_number_of_time_points>] ]
      <hybrid_number_of_devices> ::= <digit>+
      <hybrid_number_of_time_points> ::= <digit>+
  <sdat_header_line> ::= "#stress parameters:" [<whitespace>] "dev_index" <whitespace> <stress_parameter_list> <EOL>
    <stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <stress_parameter_data> ::= <time_device_data_block> | <hybrid_data_block>+
    <time_device_data_block> ::= <stress_parameter_data_line>+
    <hybrid_data_block> ::= ["#" [<whitespace>] <hybrid_data_order> <EOL>] <stress_parameter_data_line>+
      <stress_parameter_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
        <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
          <test_data> ::= <number>
;
; Notes on sdat Content
; ---------------------
; sdat has the same format as the mdat file, except for four important
; considerations:
;   1. sdat contains 1 less time point than mdat
;   2. sdat may contain only time zero data and still be valid
;   3. control devices would not be included in sdat
;   4. if the stimes file exists, sdat data will correspond to time
;       points in this stimes file.
;
; Consideration 1 stems from the fact that sdat contains stress parameter
; data, which by definition means they are measured during stress only.
; In most test systems stress parameters are measured after the time zero
; monitor data (so as not to cause pre-stress), i.e. at the beginning of 
; each stress/measure cycle.  Note that because the very first stress
; parameter reading is done at the very beginning of the first 
; stress/measure cycle, it is considered t=0 data and is labeled as such
; in the diagrams below.
;
; Consideration 2 stems from the fact that many test systems allow the
; choice of measuring stress parameters only once in the first 
; stress/measure cycle (in order to avoid extra stress due to measurement
; of stress parameters).
;
; Consideration 3 stems from the fact that control devices see no stress
; biases, so no stress parameter measurements are performed on them.
;
; Consideration 4 stems from the fact that some test systems measure (and
; log) stress parameters in a continuous or semi-continuous manner, and 
; it may not be easy to decipher which measurement points correspond to
; times in the mtimes file.  In those cases, simply reading the stimes and
; stress parameter measurement data from the original dataset is most
; efficient, and closer to the TSDF philosophy of matching the raw data as
; closely as possible.
; 
; sdat may use the same or different data orders as the mdat file in a 
; stress session. It is recommended that the mdat and sdat files use the
; same order.  The remaining sdat explanation is the same as found for
; the mdat file.
;
; <session_name> is the same session name as found in the sessioninfo file.
; <data_order> defines the "data order" used in the mdat file.  Data order
;   can be:
;       "time" (or "default")
;       "device"
;       "hybrid"
;   <data_order> is optional for the "time" (default) data order.  For the
;   hybrid data ordering, if with the same number of devices are stressed
;   for each site, then the <hybrid_number_of_devices> integer can be written
;   here.  In addition, if the same number of time points will be measured for
;   all devices, then the <hybrid_number_of_time_points> integer can also be
;   written.  If <hybrid_number_of_devices> is written on this line,
;   there is no need for embedded <hybrid_data_order> lines in each
;   <hybrid_data_block>.  Note that the optional <hybrid_number_of_time_points>
;   is redundant, as once the number of devices is known for each site,
;   the number of time points is specified in the mtimes file for each device.
; <sdat_header_line> conains <stress_parameter_list>, which is the list of
;   stress parameters that have data in the sdat file.  They are ordered
;   the same as the data columns.  In other words, the stress parameter
;   list contains the column names of the data in the sdat file.  The same
;   list will be optionally found in the sessioninfo file on the
;   "stress_parameters" row.
; <stress_parameter_data> is ordered not only by column, but also by device
; and monitor times.  There are several possible orderings.  This added
; complexity is to allow different types of test systems to output TSDF
; directly by simply appending to existing TSDF: no need to rewrite entire
; files.  This will become clear with the examples given below.
;
; For the hybrid data order with different number of devices in different
; sites (i.e. different <hybrid_data_block>), the <hybrid_data_order> is
; embedded in the <hybrid_data_block> for each site, and it must include
; the <hybrid_number_of_devices> entry.
;
; For directly plotting time-series curves for each device in a dataset,
; the "device" order is the easiest to parse, as data will be organized
; in device blocks, each block being a set of mtimes for a specific device.
;
; For directly plotting boxplots or distributons of sets of devices from
; a single monitor time point, the "time" order would be the easiest to parse.
;
; Stress parameters can be different for different devices in sdat.
; If this is the case, the <stress_parameter_list> will include all the
; stress parameters for all devices, and data padding (see the next
; paragraph) will be needed.
;
; Data points must sometimes be added to keep the data block the same
; size, or the number of columns the same.  Padded data is denoted by the
; value <padding_data>.  Testers could also output data with error
; information embedded in the values.  This data may be incorporated into
; the sdat file for later diagnostics etc, or use the default value 
; <bad_data> for bad data.
;
; Each data line (<monitor_data_line>) begins with the <dev_index> of the 
; device associated with that data row, then data corresponding each column
; defined in the <monitor_parameter_list>, with padding as needed (see above).
; The <dev_index> for each device is given in the devinfo file and is
; essentially the index into the devinfo table.
;
; ***********************
; Order by Time (Default)
; ***********************
; The default ordering is in blocks of stress/measure cycles, each block 
; containing data for a given stress/measure cycle for all devices, each
; device's data is in a separate row.  The order of devices, i.e. rows, 
; within a block is determined by the order of devices found in the 
; devinfo file.
;
; This format is most convenient for test systems that do a stress session
; on a single DUT or set of DUTs in parallel, for example a set of packaged
; parts, or a single touchdown on a wafer-level test system.  Note that
; all DUTs must have the same number of time points (time zero plus the 
; number of stress/measure cycles).  If they don't, padding data must be 
; added to devices with a smaller number of stress/measure cycles.  Padding
; data is given by the value 4e44.
;
; The order of the stress/measure cycle blocks is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L non-control devices and 
; M stress/measure cycles:
;      ------------------------------------------
;      |                                        |
;      |      Time=0, Devices 1 through L       |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t1, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Time=t2, Devices 1 through L      |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Time=tM-1, Devices 1 through L    |
;      |                                        |
;      ------------------------------------------
;
; Here's what the sdat file would look like in detail for L non-control
; devices, N stress parameters (aka sparams), and M stress/measure cycles:
; #session: <session_name>
; #data order: time
; #stress parameters: <sparam_name1> <sparam_name2> ... <sparam_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev3_t0_sparam1 data_dev3_t0_sparam2 ... data_dev3_t0_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev3_t1_sparam1 data_dev3_t1_sparam2 ... data_dev3_t1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
; data_dev3_tM-1_sparam1 data_dev3_tM-1_sparam2 ... data_dev3_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
;
; ***************
; Order by Device
; ***************
; Another way to accomodate DUTs with different numbers of stress/measure
; cycles is to order the data in blocks of devices, each block containing
; data for a given device for each stress/measure cycle.  The order of
; data blocks is given by the order of devices found in the devinfo file.
;
; This format is most convenient for a stress session on a single DUT only,
; but stepped across several devices, i.e stressing in series.  An example 
; of such a stress would be a fast WLR test on a single component over
; many sites over many wafers.
;
; The order of the stress/measure cycles is what you'd expect: starting
; with time zero data, then monotonically increasing stress time.
; Here's a block diagram of the ordering for L non-control devices and 
; M stress/measure cycles (although each device could actually have 
; different numbers of stress/measure cycles):
;      ------------------------------------------
;      |                                        |
;      |      Device 1, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 2, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;      ------------------------------------------
;      |                                        |
;      |      Device 3, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;      ------------------------------------------
;      |                                        |
;      |      Device L, Times 0 through M-1     |
;      |                                        |
;      ------------------------------------------
;
; Here's what the sdat file would look like in detail for L non-control
; devices, N stress parameters, and M stress/measure cycles:
; #session: <session_name>
; #data order: device
; #stress parameters: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev1_t2_sparam1 data_dev1_t2_sparam2 ... data_dev1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev2_t2_sparam1 data_dev2_t2_sparam2 ... data_dev2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
; data_devL_t3_sparam1 data_devL_t3_sparam2 ... data_devL_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
;
; ************
; Hybrid Order
; ************
; Of course, many WLR tests that step over many sites (and possibly
; many wafers) may also stress several devices in parallel during a 
; single touchdown.  Such a hybrid parallel/series type of stress session
; can be accomodated using the format that is a hybrid of the previous 
; two formats.
;
; Note that for the hybrid format, all devices within the same site must
; have the same number of of time points (M in this example: the t=0 plus
; M-1 stress parameter readings).  If devices have less, they need to be
; padded with 4e44 values to fill out the number of rows and columns.
; The number of times points could be different for different sites.
;
; Here's a block diagram of the ordering for S sites probed in series, 
; each site stressing L non-control devices in parallel for 
; M stress/measure cycles:
;
;  --------------------------------------------------
;  | Site 1 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices 1 through L       |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices 1 through L      |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=tM-1, Devices 1 through L    |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;  --------------------------------------------------
;  | Site 2 stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=0, Devices L+1 through 2*L   |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |      Time=t2, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   |    Time=tM-1, Devices L+1 through 2*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;               .                    .
;               .                    .
;               .                    .
;  --------------------------------------------------
;  | Site S stress data                             |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=0, Devices (S-1)*L+1 through S*L  |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t1, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=t2, Devices (S-1)*L+1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  |            .                    .              |
;  |            .                    .              |
;  |            .                    .              |
;  |   ------------------------------------------   |
;  |   |                                        |   |
;  |   | Time=tM-1, Devices (S-1)*1 through S*L |   |
;  |   |                                        |   |
;  |   ------------------------------------------   |
;  --------------------------------------------------
;
; Here's what the sdat file would look like in detail for S sites probed
; in series, each site stressing L non-control devices in parallel, 
; N stress parameters, and M stress/measure cycles (L below would 
; be replaced by an integer):
; #session: <session_name>
; #data order: hybrid L
; #stress parameters: <parameter_name1> <parameter_name2> ... <parameter_nameN>
; data_dev1_t0_sparam1 data_dev1_t0_sparam2 ... data_dev1_t0_sparamN
; data_dev1_t1_sparam1 data_dev1_t1_sparam2 ... data_dev1_t1_sparamN
; data_dev1_t2_sparam1 data_dev1_t2_sparam2 ... data_dev1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev1_tM-1_sparam1 data_dev1_tM-1_sparam2 ... data_dev1_tM-1_sparamN
; data_dev2_t0_sparam1 data_dev2_t0_sparam2 ... data_dev2_t0_sparamN
; data_dev2_t1_sparam1 data_dev2_t1_sparam2 ... data_dev2_t1_sparamN
; data_dev2_t2_sparam1 data_dev2_t2_sparam2 ... data_dev2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2_tM-1_sparam1 data_dev2_tM-1_sparam2 ... data_dev2_tM-1_sparamN
; data_devL_t0_sparam1 data_devL_t0_sparam2 ... data_devL_t0_sparamN
; data_devL_t1_sparam1 data_devL_t1_sparam2 ... data_devL_t1_sparamN
; data_devL_t3_sparam1 data_devL_t3_sparam2 ... data_devL_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_tM-1_sparam1 data_devL_tM-1_sparam2 ... data_devL_tM-1_sparamN
; data_devL+1_t0_sparam1 data_devL+1_t0_sparam2 ... data_devL+1_t0_sparamN
; data_devL+1_t1_sparam1 data_devL+1_t1_sparam2 ... data_devL+1_t1_sparamN
; data_devL+1_t2_sparam1 data_devL+1_t2_sparam2 ... data_devL+1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL+1_tM-1_sparam1 data_devL+1_tM-1_sparam2 ... data_devL+1_tM-1_sparamN
; data_devL+2_t0_sparam1 data_devL+2_t0_sparam2 ... data_devL+2_t0_sparamN
; data_devL+2_t1_sparam1 data_devL+2_t1_sparam2 ... data_devL+2_t1_sparamN
; data_devL+2_t2_sparam1 data_devL+2_t2_sparam2 ... data_devL+2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL+2_tM-1_sparam1 data_devL+2_tM-1_sparam2 ... data_devL+2_tM-1_sparamN
; data_dev2*L_t0_sparam1 data_dev2*L_t0_sparam2 ... data_dev2*L_t0_sparamN
; data_dev2*L_t1_sparam1 data_dev2*L_t1_sparam2 ... data_dev2*L_t1_sparamN
; data_dev2*L_t3_sparam1 data_dev2*L_t3_sparam2 ... data_dev2*L_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev2*L_tM-1_sparam1 data_dev2*L_tM-1_sparam2 ... data_dev2*L_tM-1_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+1_t0_sparam1 data_dev(S-1)*L+1_t0_sparam2 ... data_dev(S-1)*L+1_t0_sparamN
; data_dev(S-1)*L+1_t1_sparam1 data_dev(S-1)*L+1_t1_sparam2 ... data_dev(S-1)*L+1_t1_sparamN
; data_dev(S-1)*L+1_t2_sparam1 data_dev(S-1)*L+1_t2_sparam2 ... data_dev(S-1)*L+1_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+1_tM-1_sparam1 data_dev(S-1)*L+1_tM-1_sparam2 ... data_dev(S-1)*L+1_tM-1_sparamN
; data_dev(S-1)*L+2_t0_sparam1 data_dev(S-1)*L+2_t0_sparam2 ... data_dev(S-1)*L+2_t0_sparamN
; data_dev(S-1)*L+2_t1_sparam1 data_dev(S-1)*L+2_t1_sparam2 ... data_dev(S-1)*L+2_t1_sparamN
; data_dev(S-1)*L+2_t2_sparam1 data_dev(S-1)*L+2_t2_sparam2 ... data_dev(S-1)*L+2_t2_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_dev(S-1)*L+2_tM-1_sparam1 data_dev(S-1)*L+2_tM-1_sparam2 ... data_dev(S-1)*L+2_tM-1_sparamN
; data_devS*L_t0_sparam1 data_devS*L_t0_sparamS ... data_devS*L_t0_sparamN
; data_devS*L_t1_sparam1 data_devS*L_t1_sparamS ... data_devS*L_t1_sparamN
; data_devS*L_t3_sparam1 data_devS*L_t3_sparamS ... data_devS*L_t3_sparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devS*L_tM-1_sparam1 data_devS*L_tM-1_sparamS ... data_devS*L_tM-1_sparamN
;
; Note one more aspect of the hybrid data ordering. In many wafer level
; test programs, each site would contain multiple modules tested in
; sequence.  For example, each site testing might start off with a simple
; probecheck, which is a measure of the parasitic resistance in the probes
; and probe pads and would have nothing to do with the subsequent reliability
; testing of other modules/devices in the site.  This is not a issue for
; TSDF, as TSDF requires a single test_type in a dataset.  Test programs
; that have probechecks and/or multiple test_types create output that would
; by definition have to be converted to multiple TSDF stress sessions.  This
; could be done at the test system level, if the test shell supports creation
; of multiple data files from a run.  If not, the conversion program from
; the native test sysem format to TSDF would have to account for the
; multiple test_types in the original dataset.
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; *********
; * ivdat *
; *********
;
; TSDF ivdat file syntax in Backus-Naur Form
;
<ivdat_file> ::= <session_line> <device_id_line> <ivdat>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <device_id_line> ::= "#IV Data for device " <dev_info> <EOL>
  <ivdat> ::= (<ivdat_block> [<EOL>])+
    <ivdat_block> ::= [<description_line>] <format> <iv_header_line> <iv_data> "#end" <EOL>
      <description_line> ::= "#" <text> <EOL>
      <format> ::= "#" [<whitespace>] "format=" [<whitespace>] ("short" | "long") <EOL>
      <iv_header_line> ::=  <header_line_short> | <header_line_long> <EOL>
        <header_line_short> ::= "#" [<whitespace>] <time_interval> <whitespace> <iv_label> <whitespace> <measured_param_list> "@" <sweep_def> <whitespace> [<step_def>] <bias_list> [<units_string>] [<sweep_rate>] <EOL>
        <header_line_long> ::= "#" [<whitespace>] <time_interval> <whitespace> <iv_label> <whitespace> <measured_param_list> [<bias_list>] [<units_string>] [<sweep_rate>] <EOL>
          <time_interval> ::= "t=" ("pre_stress" [<prestress_index>] | "post_stress" [<poststress_index>] | <digit>+)
            <prestress_index> ::= <digit>+
            <poststress_index> ::= <digit>+
          <iv_label> ::= "IV=" <alphanumeric>+
          <measured_param_list> ::= <measured_param> | (<measured_param> "," <measured_param_list>)
            <measured_param> ::= <alphanumeric>+
          <sweep_def> ::= <sweep_var_name> ["[" <units> "]"] "=" <sweep_values>
          <step_def> ::= <step_var_name> ["[" <units> "]"] "=" <sweep_values>
            <sweep_var_name> ::= <alphanumeric>+
            <step_var_name> ::= <alphanumeric>+
            <sweep_values> ::= "[" <number_list> "]"
          <bias_list> ::= <bias_def> | (<bias_def> <bias_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <number> <whitespace>
              <bias_name> ::= <alphanumeric>+
          <units_string> ::= "units=" <units_list>
            <units_list> ::= <units> | (<units> "," <units_list>)
          <sweep_rate> ::= "sweep_rate=" <number> [<whitespace>] <units>
      <iv_data> ::= <ivdata_line>+
        <ivdata_line> ::= <ivdata_pt>+ <EOL>
          <ivdata_pt> ::= <number> <whitespace>
;
; Notes on ivdat Content
; ----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <device_id_line> is informational. For example: "IV data for device 5"
; <ivdat> is split up into blocks, one IV curve per block
; <ivdat_block> is the IV curve, consisting of metadata followed by
;   the IV data.  The metadata consists of an optional <description_line>,
;   a required <format> line,  and a required header line <iv_header_line>.
; <iv_header_line> format (and IV data format) will depend on the <format> line
;   contents.  There are 2 possible formats, as described below.
; <description_line> (optional, but highly recommended), Examples:
;          "Isub vs Vg for Vd=1.8 to 2.8 V"
;          "Id vs Vg for Vd=0.05 V"
; <format> (one of these two):
;          "format=short"
;          "format=long"
; <iv_header_line> for format=short gives the following information:
;        <time_interval>: the time point (index found in mtimes file), or
;          pre_stress, or post_stress with or without index values.  It is NOT
;          the actual stress time.
;        <iv_label>: defines a label for the curve
;        <measured_param_list>: defines the measurement parameters
;        <sweep_def>: defines sweep parameters
;        <step_def>: defines step parameters
;        <bias_list>: defines other terminal biases
;        <units_string>: (optional) defines units of the measurement parameters
;        <sweep_rate>: (optional) defines the sweep rate of the IV sweep, e.g.
;          as V/s or MV/cm/s or I/s.  Units are are not optional, so the value
;          given will not be ambiguous.
;        Using the example "Isub vs Vg for Vd=1.8 to 2.8 V" IV for t=0, the
;        header line would be:
;          # t=0 iv=B Isub@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        Note that <time_interval> is 0,1,2,3..., i.e. not the stress time,
;        but the stress interval index, i.e. t=0 is time zero.
;        Also valid are the following time intervals:
;           t=pre_stress -- for IV curves taken before the start of stress,
;             even before any t=0 IV curves.
;           t=pre_stress2 -- for IV curves taken before the start of stress,
;             but after t=pre_stress IV curves that are known to cause
;             degradation.
;           t=post_stress -- for IV curves taken after the stress session
;             has finished.
;        The <iv_label> can be any label the user wants.  There is an
;        established convention for iv labels for some common IV curves:
;           MOSFET linear Id-Vg: iv=L
;           MOSFET saturation Id-Vg: iv=S
;           MOSFET full Id-Vd family of curves: iv=F
;           MOSFET Isub-Vg family of curves: iv=B
;           MOSFET Igate-Vg family of curves: iv=G
;           Any MOSFET curve performed with source and drain reversed: add
;             suffix 'R' to the label.  Examples: 'LR', 'SR', 'FR', 'BR'
;           Capacitor ramp IV data: iv=Vramp or iv=Jramp depending on type
;             of ramp
;           Bipolar Gummel plot: iv=Gummel
;           Bipolar full Ic-Vce family of curves: iv=F
;           ?* Predefine other BJT IV's here *?
;        The <measured_param_list> is a comma separated list of names of
;        the measured parameter or parameters (a list of <measured_param>'s).
;        This is allowed because many test systems can measure several
;        terminal voltages or currents simultaneously in a single sweep.
;        If the example here had been 
;             "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        the <iv_header_line> would be:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        Note that if <measured_param> starts with 'I' or 'i', the units
;        are assumed to be 'A' (amps), and if it starts with 'V' or 'v',
;        the units are assumed to be 'V' (volts).  If these are not the
;        correct units, or <measured_param> starts with a different letter,
;        the units can be defined in the optional <units_string> as the last 
;        entry of the <iv_header_line>.  For example, if Isub is in 'mA' 
;        (milliamps), the <iv_header_line> would be:
;          # t=0 iv=B Isub@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=mA
;        or for Isub and Id milliamps:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=mA,mA
;        Note that to remove ambiguity, if any <measured_param> in 
;        <measured_param_list> has a specified units, all <measured_param>'s
;        must have their units specified.  For Isub in amps and Id in mA:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0 units=A,mA
;
;        The primary sweep, <sweep_def>, is defined next, as a list of 
;        real numbers.  The values don't have to be monotonically increasing
;        or decreasing, but they normally do, as they must correspond to 
;        each sweep value used in the IV measurement.  The <sweep_def> format
;        is equivalent to Matlab's convention for defining lists (vectors
;        actually in Matlab's parlance): a list of whitespace separated
;        elements, each element being a real number or integer, or the 
;        Matlab shorthand notation element=start:step:stop.  The latter
;        notation is for defining the start, step, and stop values of the 
;        sweep.  The list is monotonically increasing if
;        the <start> value is less than the <stop> value and the <step> value
;        is positive.  The list is monotonically decreasing if the <start>
;        value is greater than the <stop> value and the <step> value is
;        negative.
;        Most IV sweeps will be a constant step, so an IV sweep from 0 to 
;        5 V with a 0.05 V step could be written compactly as: [0:0.05:5].  
;        IV curves with different step values in different parts of the sweep
;        can be accommodated with a list using multiple start:step:stop 
;        elements.  For example, an IV that steps 0.05 V between 0 and 2,
;        then 0.02 V steps between 2 and 3.3 V would be written as:
;        [0:0.05:2 2.02:0.02:3.3].
;        The sweep parameters have the same convention for automatically
;        setting units as the measured parameters.  If the <sweep_var_name>
;        starts with 'I' or 'i', units are set to 'A' (amps), and if it
;        starts with 'V' or 'v', units are set to 'V' (volts).  If these
;        are not the correct units, or the <sweep_var_name> starts with a
;        different letter, the units can be defined in the adjacent [<units>]
;        string.  For example, Vg in mV:
;          # t=0 iv=B Isub@Vg[mV]=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;         
;        The secondary sweep, which is called the step here, <step_def>, is
;        optional as not all IV curves use a stepped parameter.  <step_def>
;        has the same format as <sweep_def>.
;
;        The remaining terminal voltages are defined in <bias_list> and are
;        assumed to be DC values.  Electrical ground is 0 V as usual.
;        <bias_name> has the same convention for automatically
;        setting units as the sweep and step parameters.  If the <bias_name>
;        starts with 'I' or 'i', units are set to 'A' (amps), and if it
;        starts with 'V' or 'v', units are set to 'V' (volts).  If these
;        are not the correct units, or the <bias_name> starts with a
;        different letter, the units can be defined in the adjacent [<units>]
;        string.  For example, Vd in mV for a linear Id-Vg sweep:
;          # t=0 iv=L Id@Vg=[0:0.02:2.8] Vd[mV]=100 Vs=0 Vb=0
;
;        Finally, comes the data!  There will be as many <iv_data_line>'s
;        (i.e. rows) as there are sweep values defined in <sweep_def>.
;        There will be as many <iv_data_pt>'s (i.e. columns) as the
;        number of step values times the number of measured parameters.
;        For our example of "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        with the following <iv_header_line>:
;          # t=0 iv=B Isub,Id@Vg=[0:0.02:2.8] Vd=[1.8:0.5:2.8] Vs=0 Vb=0
;        the <iv_data> would look like this, using Isub(Vg,Vd) and Id(Vg,Vd):
;      
; Isub(0,1.8) Isub(0,2.3) Isub(0,2.8) Id(0,1.8) Id(0,2.3) Id(0,2.8)
; Isub(.02,1.8) Isub(.02,2.3) Isub(.02,2.8) Id(.02,1.8) Id(.02,2.3) Id(.02,2.8)
; Isub(.04,1.8) Isub(.04,2.3) Isub(.04,2.8) Id(.04,1.8) Id(.04,2.3) Id(.04,2.8)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Isub(2.8,1.8) Isub(2.8,2.3) Isub(2.8,2.8) Id(2.8,1.8) Id(2.8,2.3) Id(2.8,2.8)
;
; <iv_header_line> for format=long gives the following information:
;        <time_interval>: the time point (see above)
;        <iv_label>: defines a label for the curve (see above)
;        <measured_param_list>: defines the measurement parameters (see above)
;           format=long, there is no sweep parameter definition.
;        <bias_list>: defines other terminal biases (see above)
;        <units_string>: (optional) defines units of the measurement parameters
;          (see above).
;        The <sweep_def> and <step_def> entries are not used.
;        Using the example "Isub vs Vg for Vd=1.8 to 2.8 V" IV for t=0, the
;        header line would be:
;          # t=0 iv=B Vg,Vd,Isub Vs=0 Vb=0
;        The <measured_param_list> is a comma separated list of names of
;        the measured parameter or parameters (a list of <measured_param>'s).
;        This is allowed because many test systems can measure several
;        terminal voltages or currents simultaneously in a single sweep.
;        If the example here had been 
;             "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        the <iv_header_line> would be:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0
;        The same convention as used in the format=short format for
;        specifying units applies.
;          # t=0 iv=B Vg,Vd,Isub Vs=0 Vb=0 units=V,V,mA
;        or for Isub and Id milliamps:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0 units=V,V,mA,mA
;        In the above examples, to remove ambiguity, all <measured_param>'s
;        had their units specified.  For Isub in amps and Id in mA, and Vg
;        in mV:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0 units=mV,V,A,mA
;
;        Terminal voltages that are not explicitly written in the IV data
;        are defined in <bias_list> and are assumed to be DC values.
;        Electrical ground is 0 V as usual.
;        <bias_name> has the same convention for automatically
;        setting units as already discussed.
;          # t=0 iv=L Vg,Id Vd[mV]=100 Vs=0 Vb=0
;
;        Finally, comes the data!  There will be as many <iv_data_line>'s
;        (i.e. rows) as there are sweep values defined in <sweep_def>.
;        There will be as many <iv_data_pt>'s (i.e. columns) as the
;        number of step values times the number of measured parameters.
;        For our example of "Isub and Id vs Vg for Vd=1.8 to 2.8 V",
;        with the following <iv_header_line>:
;          # t=0 iv=B Vg,Vd,Isub,Id Vs=0 Vb=0
;        the <iv_data> would look like this, assuming N Vg steps and M Vd steps:
;      
; Vg(1),Vd(1),Isub(1,1) Id(1,1)
; Vg(2),Vd(1),Isub(2,1) Id(2,1)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(1),Isub(N,1) Id(N,1)
; Vg(1),Vd(2),Isub(1,2) Id(1,2)
; Vg(2),Vd(2),Isub(2,2) Id(2,2)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(2),Isub(N,2) Id(N,2)
;       .              .             .           .           .           .
;       .              .             .           .           .           .
;       .              .             .           .           .           .
; Vg(N),Vd(M),Isub(N,M) Id(N,M)
;
; Important note: for every Vd step, the number of Vg steps could be different.
;  It is up to the analysis program to detect this in order to plot any 
;  family of curves correctly.  This behavior is not ideal, but is needed
;  to accomodate the IV data output of certain commerically available testers
;  (Aetrium 1164 testers).
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; **********
; * predef *
; **********
; 
; TSDF predef file syntax in Backus-Naur Form
; 
<predef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= (<mdef_block> [<EOL>]) | (<mdef_block> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" <bias_def_list> [<units_string>] <EOL>
          <parameter_name> ::= <alphanumeric>+
          <bias_def_list> ::= <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
              <bias_name> ::= <alphanumeric>+
              <bias_value> ::= <number>
          <units_string> ::= "units=" <units>
;
; Notes on predef Content
; -----------------------
; <session_name> is the same session name as found in the sessioninfo file.
; The predef file has the exact same format as the mdef file.  It is used in 
;   situations where a stress session includes a set of pre-stress parameter
;   measurements that can be different than the monitor parameters found
;   in the mdef and mdat files.  See the mdef section for more notes on
;   this parameter definition file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; **********
; * predat *
; **********
;
; TSDF predat file syntax in Backus-Naur Form
;
<predat_file> ::= <session_line> <predat_header_line> <pre_stress_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <predat_header_line> ::= "#pre-stress:" [<whitespace>] "dev_index" <whitespace> <pre_stress_parameter_list> <EOL>
    <pre_stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <pre_stress_data> ::= <pre_stress_data_line>+
    <pre_stress_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
      <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
;
; Notes on predat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <predat_file> has the same format as the mdat file, except since it is
;    data for a single time point (pre-stress), there is no variable data
;    order.  All data is presented in rows starting with the first device
;    and going through to the last device, in order the devices appear in
;    the devinfo file.
; Here's a block diagram of the ordering for L devices:
;      ------------------------------------------
;      |                                        |
;      |      Time=pre, Devices 1 through L     |
;      |                                        |
;      ------------------------------------------
;
; Here's what the predat file would look like in detail for L devices, and
; N pre-stress parameters:
; #session: <session_name>
; #pre-stress: <preparam_name1> <preparam_name2> ... <preparam_nameN>
; data_dev1_preparam1 data_dev1_preparam2 ... data_dev1_preparamN
; data_dev2_preparam1 data_dev2_preparam2 ... data_dev2_preparamN
; data_dev3_preparam1 data_dev3_preparam2 ... data_dev3_preparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_preparam1 data_devL_preparam2 ... data_devL_preparamN
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; ***********
; * postdef *
; ***********
; 
; TSDF postdef file syntax in Backus-Naur Form
; 
<postdef_file> ::= <session_line> <mdefs>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <mdefs> ::= (<mdef_block> [<EOL>]) | (<mdef_block> <mdefs>)
    <mdef_block> ::= [<device_line>] <device_mdefs>
      <device_line> ::= [<whitespace>] ("Device" <whitespace> <digit>+ | "Devices" <whitespace> <device_list>) <EOL>
        <device_list> ::= <integer_list>
      <device_mdefs> ::= <mdef_line> | (<mdef_line> <device_mdefs>)
        <mdef_line> ::= [<whitespace>] <parameter_name> ":" <bias_def_list> [<units_string>] <EOL>
          <parameter_name> ::= <alphanumeric>+
          <bias_def_list> ::= <bias_def> | (<bias_def> <whitespace> <bias_def_list>)
            <bias_def> ::= <bias_name> ["[" <units> "]"] "=" <bias_value>
              <bias_name> ::= <alphanumeric>+
              <bias_value> ::= <number>
          <units_string> ::= "units=" <units>
;
; Notes on postdef Content
; ------------------------
; <session_name> is the same session name as found in the sessioninfo file.
; The postdef file has the exact same format as the mdef file.  It is used in 
;   situations where a stress session includes a set of post-stress parameter
;   measurements that can be different than the monitor parameters found
;   in the mdef and mdat files.  See the mdef section for more notes on
;   this parameter definition file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; **********
; * postdat *
; **********
;
; TSDF postdat file syntax in Backus-Naur Form
;
<postdat_file> ::= <session_line> <postdat_header_line> <post_stress_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <postdat_header_line> ::= "#post-stress:" [<whitespace>] "dev_index" <whitespace> <post_stress_parameter_list> <EOL>
    <post_stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <post_stress_data> ::= <post_stress_data_line>+
    <post_stress_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
      <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
;
; Notes on postdat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <postdat_file> has the same format as the mdat file, except since it is
;    data for a single time point (post-stress), there is no variable data
;    order.  All data is presented in rows starting with the first device
;    and going through to the last device, in order the devices appear in
;    the devinfo file.
; Here's a block diagram of the ordering for L devices:
;      ------------------------------------------
;      |                                        |
;      |      Time=post, Devices 1 through L    |
;      |                                        |
;      ------------------------------------------
;
; Here's what the postdat file would look like in detail for L devices, and
; N post-stress parameters:
; #session: <session_name>
; #post-stress: <postparam_name1> <postparam_name2> ... <postparam_nameN>
; data_dev1_postparam1 data_dev1_postparam2 ... data_dev1_postparamN
; data_dev2_postparam1 data_dev2_postparam2 ... data_dev2_postparamN
; data_dev3_postparam1 data_dev3_postparam2 ... data_dev3_postparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_postparam1 data_devL_postparam2 ... data_devL_postparamN
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TSDF lifedat file syntax in Backus-Naur Form
;
<lifedat_file> ::= <session_line> <lifedat_header_line> <post_stress_data>
  <session_line> ::= "#session:" [<whitespace>] <session_name> <EOL>
    <session_name> ::= <alphanumeric>+
  <lifedat_header_line> ::= "#post-stress:" [<whitespace>] "dev_index" <whitespace> <post_stress_parameter_list> <EOL>
    <post_stress_parameter_list> ::= <parameter_name>+
      <parameter_name> ::= <alphanumeric>+ <whitespace>
  <post_stress_data> ::= <post_stress_data_line>+
    <post_stress_data_line> ::= [<whitespace>] <dev_index> <whitespace> <data_point>+ <EOL>
      <data_point> ::= (<test_data>|<padding_data>|<bad_data>) <whitespace>
        <test_data> ::= <number>
;
; Notes on lifedat Content
; ---------------------
; <session_name> is the same session name as found in the sessioninfo file.
; <lifedat_file> has the same format as the mdat file, except since it is
;    data for a single time point (post-stress), there is no variable data
;    order.  All data is presented in rows starting with the first device
;    and going through to the last device, in order the devices appear in
;    the devinfo file.
; Here's a block diagram of the ordering for L devices:
;      ------------------------------------------
;      |                                        |
;      |      Time=post, Devices 1 through L    |
;      |                                        |
;      ------------------------------------------
;
; Here's what the lifedat file would look like in detail for L devices, and
; N post-stress parameters:
; #session: <session_name>
; #post-stress: <postparam_name1> <postparam_name2> ... <postparam_nameN>
; data_dev1_postparam1 data_dev1_postparam2 ... data_dev1_postparamN
; data_dev2_postparam1 data_dev2_postparam2 ... data_dev2_postparamN
; data_dev3_postparam1 data_dev3_postparam2 ... data_dev3_postparamN
;           .                    .                        .
;           .                    .                        .
;           .                    .                        .
; data_devL_postparam1 data_devL_postparam2 ... data_devL_postparamN
;
